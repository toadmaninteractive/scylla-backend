# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule IngestProtocol do

  defmodule Envelope do

    @enforce_keys [:events]
    defstruct [events: nil]

    @type t :: %Envelope{events: [Igor.Json.json()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      events = Igor.Json.parse_field!(json, "events", {:list, :json})
      %Envelope{events: events}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{events: events} = args
      %{
        "events" => Igor.Json.pack_value(events, {:list, :json})
      }
    end

  end

  defmodule IngestorResponse do

    @enforce_keys [:ingested_count]
    defstruct [ingested_count: nil, errors: nil]

    @type t :: %IngestorResponse{ingested_count: integer, errors: [Igor.Json.json()] | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      ingested_count = Igor.Json.parse_field!(json, "ingested_count", :int)
      errors = Igor.Json.parse_field!(json, "errors", {:list, :json}, nil)
      %IngestorResponse{ingested_count: ingested_count, errors: errors}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{ingested_count: ingested_count, errors: errors} = args
      %{}
        |> Igor.Json.pack_field("ingested_count", ingested_count, :int)
        |> Igor.Json.pack_field("errors", errors, {:list, :json})
    end

  end

  defmodule IngestError do

    @type t :: :invalid_data | :invalid_schema | :invalid_event | :invalid_event_tag | :unknown_event_tag | :project_not_exists

    defguard is_ingest_error(value) when value === :invalid_data or value === :invalid_schema or value === :invalid_event or value === :invalid_event_tag or value === :unknown_event_tag or value === :project_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_data"), do: :invalid_data
    def from_string!("invalid_schema"), do: :invalid_schema
    def from_string!("invalid_event"), do: :invalid_event
    def from_string!("invalid_event_tag"), do: :invalid_event_tag
    def from_string!("unknown_event_tag"), do: :unknown_event_tag
    def from_string!("project_not_exists"), do: :project_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_data), do: "invalid_data"
    def to_string!(:invalid_schema), do: "invalid_schema"
    def to_string!(:invalid_event), do: "invalid_event"
    def to_string!(:invalid_event_tag), do: "invalid_event_tag"
    def to_string!(:unknown_event_tag), do: "unknown_event_tag"
    def to_string!(:project_not_exists), do: "project_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_data"), do: :invalid_data
    def from_json!("invalid_schema"), do: :invalid_schema
    def from_json!("invalid_event"), do: :invalid_event
    def from_json!("invalid_event_tag"), do: :invalid_event_tag
    def from_json!("unknown_event_tag"), do: :unknown_event_tag
    def from_json!("project_not_exists"), do: :project_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_data), do: "invalid_data"
    def to_json!(:invalid_schema), do: "invalid_schema"
    def to_json!(:invalid_event), do: "invalid_event"
    def to_json!(:invalid_event_tag), do: "invalid_event_tag"
    def to_json!(:unknown_event_tag), do: "unknown_event_tag"
    def to_json!(:project_not_exists), do: "project_not_exists"

  end

  defmodule SchemaError do

    @type t :: :invalid_data | :invalid_schema | :clashing_type | :unknown_type | :invalid_name | :invalid_type_definition | :update_failed | :project_not_exists

    defguard is_schema_error(value) when value === :invalid_data or value === :invalid_schema or value === :clashing_type or value === :unknown_type or value === :invalid_name or value === :invalid_type_definition or value === :update_failed or value === :project_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_data"), do: :invalid_data
    def from_string!("invalid_schema"), do: :invalid_schema
    def from_string!("clashing_type"), do: :clashing_type
    def from_string!("unknown_type"), do: :unknown_type
    def from_string!("invalid_name"), do: :invalid_name
    def from_string!("invalid_type_definition"), do: :invalid_type_definition
    def from_string!("update_failed"), do: :update_failed
    def from_string!("project_not_exists"), do: :project_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_data), do: "invalid_data"
    def to_string!(:invalid_schema), do: "invalid_schema"
    def to_string!(:clashing_type), do: "clashing_type"
    def to_string!(:unknown_type), do: "unknown_type"
    def to_string!(:invalid_name), do: "invalid_name"
    def to_string!(:invalid_type_definition), do: "invalid_type_definition"
    def to_string!(:update_failed), do: "update_failed"
    def to_string!(:project_not_exists), do: "project_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_data"), do: :invalid_data
    def from_json!("invalid_schema"), do: :invalid_schema
    def from_json!("clashing_type"), do: :clashing_type
    def from_json!("unknown_type"), do: :unknown_type
    def from_json!("invalid_name"), do: :invalid_name
    def from_json!("invalid_type_definition"), do: :invalid_type_definition
    def from_json!("update_failed"), do: :update_failed
    def from_json!("project_not_exists"), do: :project_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_data), do: "invalid_data"
    def to_json!(:invalid_schema), do: "invalid_schema"
    def to_json!(:clashing_type), do: "clashing_type"
    def to_json!(:unknown_type), do: "unknown_type"
    def to_json!(:invalid_name), do: "invalid_name"
    def to_json!(:invalid_type_definition), do: "invalid_type_definition"
    def to_json!(:update_failed), do: "update_failed"
    def to_json!(:project_not_exists), do: "project_not_exists"

  end

  defmodule SchemaConflictError do

    @type t :: :same_schema | :dangerous_action

    defguard is_schema_conflict_error(value) when value === :same_schema or value === :dangerous_action

    @spec from_string!(String.t()) :: t()
    def from_string!("same_schema"), do: :same_schema
    def from_string!("dangerous_action"), do: :dangerous_action

    @spec to_string!(t()) :: String.t()
    def to_string!(:same_schema), do: "same_schema"
    def to_string!(:dangerous_action), do: "dangerous_action"

    @spec from_json!(String.t()) :: t()
    def from_json!("same_schema"), do: :same_schema
    def from_json!("dangerous_action"), do: :dangerous_action

    @spec to_json!(t()) :: String.t()
    def to_json!(:same_schema), do: "same_schema"
    def to_json!(:dangerous_action), do: "dangerous_action"

  end

end
