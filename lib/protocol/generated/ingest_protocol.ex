# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule IngestProtocol do

  defmodule Envelope do

    @enforce_keys [:events]
    defstruct [events: nil]

    @type t :: %Envelope{events: [Igor.Json.json()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      events = Igor.Json.parse_field!(json, "events", {:list, :json})
      %Envelope{events: events}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{events: events} = args
      %{
        "events" => Igor.Json.pack_value(events, {:list, :json})
      }
    end

  end

  defmodule IngestorResponse do

    @enforce_keys [:ingested_count]
    defstruct [ingested_count: nil, errors: nil]

    @type t :: %IngestorResponse{ingested_count: integer, errors: [Igor.Json.json()] | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      ingested_count = Igor.Json.parse_field!(json, "ingested_count", :int)
      errors = Igor.Json.parse_field!(json, "errors", {:list, :json}, nil)
      %IngestorResponse{ingested_count: ingested_count, errors: errors}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{ingested_count: ingested_count, errors: errors} = args
      %{}
        |> Igor.Json.pack_field("ingested_count", ingested_count, :int)
        |> Igor.Json.pack_field("errors", errors, {:list, :json})
    end

  end

  defmodule IngestError do

    @type t ::
      :invalid_schema #
    | :invalid_event #
    | :invalid_event_tag #
    | :unknown_event_tag #

    defguard is_ingest_error(value) when value === :invalid_schema or value === :invalid_event or value === :invalid_event_tag or value === :unknown_event_tag

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_schema"), do: :invalid_schema
    def from_string!("invalid_event"), do: :invalid_event
    def from_string!("invalid_event_tag"), do: :invalid_event_tag
    def from_string!("unknown_event_tag"), do: :unknown_event_tag

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_schema), do: "invalid_schema"
    def to_string!(:invalid_event), do: "invalid_event"
    def to_string!(:invalid_event_tag), do: "invalid_event_tag"
    def to_string!(:unknown_event_tag), do: "unknown_event_tag"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_schema"), do: :invalid_schema
    def from_json!("invalid_event"), do: :invalid_event
    def from_json!("invalid_event_tag"), do: :invalid_event_tag
    def from_json!("unknown_event_tag"), do: :unknown_event_tag

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_schema), do: "invalid_schema"
    def to_json!(:invalid_event), do: "invalid_event"
    def to_json!(:invalid_event_tag), do: "invalid_event_tag"
    def to_json!(:unknown_event_tag), do: "unknown_event_tag"

  end

  defmodule SchemaError do

    @type t ::
      :clashing_type #
    | :unknown_type #
    | :invalid_name #
    | :invalid_type_definition #
    | :update_failed #

    defguard is_schema_error(value) when value === :clashing_type or value === :unknown_type or value === :invalid_name or value === :invalid_type_definition or value === :update_failed

    @spec from_string!(String.t()) :: t()
    def from_string!("clashing_type"), do: :clashing_type
    def from_string!("unknown_type"), do: :unknown_type
    def from_string!("invalid_name"), do: :invalid_name
    def from_string!("invalid_type_definition"), do: :invalid_type_definition
    def from_string!("update_failed"), do: :update_failed

    @spec to_string!(t()) :: String.t()
    def to_string!(:clashing_type), do: "clashing_type"
    def to_string!(:unknown_type), do: "unknown_type"
    def to_string!(:invalid_name), do: "invalid_name"
    def to_string!(:invalid_type_definition), do: "invalid_type_definition"
    def to_string!(:update_failed), do: "update_failed"

    @spec from_json!(String.t()) :: t()
    def from_json!("clashing_type"), do: :clashing_type
    def from_json!("unknown_type"), do: :unknown_type
    def from_json!("invalid_name"), do: :invalid_name
    def from_json!("invalid_type_definition"), do: :invalid_type_definition
    def from_json!("update_failed"), do: :update_failed

    @spec to_json!(t()) :: String.t()
    def to_json!(:clashing_type), do: "clashing_type"
    def to_json!(:unknown_type), do: "unknown_type"
    def to_json!(:invalid_name), do: "invalid_name"
    def to_json!(:invalid_type_definition), do: "invalid_type_definition"
    def to_json!(:update_failed), do: "update_failed"

  end

  defmodule SchemaConflictError do

    @type t ::
      :dangerous_action #

    defguard is_schema_conflict_error(value) when value === :dangerous_action

    @spec from_string!(String.t()) :: t()
    def from_string!("dangerous_action"), do: :dangerous_action

    @spec to_string!(t()) :: String.t()
    def to_string!(:dangerous_action), do: "dangerous_action"

    @spec from_json!(String.t()) :: t()
    def from_json!("dangerous_action"), do: :dangerous_action

    @spec to_json!(t()) :: String.t()
    def to_json!(:dangerous_action), do: "dangerous_action"

  end

  defmodule OldSchemaResponse do

    @enforce_keys [:schema, :order, :order_by]
    defstruct [schema: nil, order: nil, order_by: nil]

    @type t :: %OldSchemaResponse{schema: %{String.t() => String.t()}, order: [String.t()], order_by: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      schema = Igor.Json.parse_field!(json, "schema", {:map, :string, :string})
      order = Igor.Json.parse_field!(json, "order", {:list, :string})
      order_by = Igor.Json.parse_field!(json, "order_by", :string)
      %OldSchemaResponse{schema: schema, order: order, order_by: order_by}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{schema: schema, order: order, order_by: order_by} = args
      %{
        "schema" => Igor.Json.pack_value(schema, {:map, :string, :string}),
        "order" => Igor.Json.pack_value(order, {:list, :string}),
        "order_by" => Igor.Json.pack_value(order_by, :string)
      }
    end

  end

end
