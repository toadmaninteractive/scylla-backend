# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule Analytics do

  defmodule EventName do

    @type t ::
      :aa_purchase #
    | :achievement_progress #
    | :add_looter #
    | :calculate_master_looter #
    | :corpse_create #
    | :corpse_dust #
    | :corpse_from_world #
    | :corpse_lock #
    | :corpse_move_permission #
    | :corpse_to_world #
    | :free_grab #
    | :give_item #
    | :kill #
    | :kill_credit #
    | :leave_item #
    | :level_change #
    | :loot #
    | :loot_do_roll #
    | :resurrect #
    | :try_loot_item #
    | :udp_stats #
    | :xp_change #

    defguard is_event_name(value) when value === :aa_purchase or value === :achievement_progress or value === :add_looter or value === :calculate_master_looter or value === :corpse_create or value === :corpse_dust or value === :corpse_from_world or value === :corpse_lock or value === :corpse_move_permission or value === :corpse_to_world or value === :free_grab or value === :give_item or value === :kill or value === :kill_credit or value === :leave_item or value === :level_change or value === :loot or value === :loot_do_roll or value === :resurrect or value === :try_loot_item or value === :udp_stats or value === :xp_change

    @spec from_string!(String.t()) :: t()
    def from_string!("aa_purchase"), do: :aa_purchase
    def from_string!("achievement_progress"), do: :achievement_progress
    def from_string!("add_looter"), do: :add_looter
    def from_string!("calculate_master_looter"), do: :calculate_master_looter
    def from_string!("corpse_create"), do: :corpse_create
    def from_string!("corpse_dust"), do: :corpse_dust
    def from_string!("corpse_from_world"), do: :corpse_from_world
    def from_string!("corpse_lock"), do: :corpse_lock
    def from_string!("corpse_move_permission"), do: :corpse_move_permission
    def from_string!("corpse_to_world"), do: :corpse_to_world
    def from_string!("free_grab"), do: :free_grab
    def from_string!("give_item"), do: :give_item
    def from_string!("kill"), do: :kill
    def from_string!("kill_credit"), do: :kill_credit
    def from_string!("leave_item"), do: :leave_item
    def from_string!("level_change"), do: :level_change
    def from_string!("loot"), do: :loot
    def from_string!("loot_do_roll"), do: :loot_do_roll
    def from_string!("resurrect"), do: :resurrect
    def from_string!("try_loot_item"), do: :try_loot_item
    def from_string!("udp_stats"), do: :udp_stats
    def from_string!("xp_change"), do: :xp_change

    @spec to_string!(t()) :: String.t()
    def to_string!(:aa_purchase), do: "aa_purchase"
    def to_string!(:achievement_progress), do: "achievement_progress"
    def to_string!(:add_looter), do: "add_looter"
    def to_string!(:calculate_master_looter), do: "calculate_master_looter"
    def to_string!(:corpse_create), do: "corpse_create"
    def to_string!(:corpse_dust), do: "corpse_dust"
    def to_string!(:corpse_from_world), do: "corpse_from_world"
    def to_string!(:corpse_lock), do: "corpse_lock"
    def to_string!(:corpse_move_permission), do: "corpse_move_permission"
    def to_string!(:corpse_to_world), do: "corpse_to_world"
    def to_string!(:free_grab), do: "free_grab"
    def to_string!(:give_item), do: "give_item"
    def to_string!(:kill), do: "kill"
    def to_string!(:kill_credit), do: "kill_credit"
    def to_string!(:leave_item), do: "leave_item"
    def to_string!(:level_change), do: "level_change"
    def to_string!(:loot), do: "loot"
    def to_string!(:loot_do_roll), do: "loot_do_roll"
    def to_string!(:resurrect), do: "resurrect"
    def to_string!(:try_loot_item), do: "try_loot_item"
    def to_string!(:udp_stats), do: "udp_stats"
    def to_string!(:xp_change), do: "xp_change"

    @spec from_json!(String.t()) :: t()
    def from_json!("aa_purchase"), do: :aa_purchase
    def from_json!("achievement_progress"), do: :achievement_progress
    def from_json!("add_looter"), do: :add_looter
    def from_json!("calculate_master_looter"), do: :calculate_master_looter
    def from_json!("corpse_create"), do: :corpse_create
    def from_json!("corpse_dust"), do: :corpse_dust
    def from_json!("corpse_from_world"), do: :corpse_from_world
    def from_json!("corpse_lock"), do: :corpse_lock
    def from_json!("corpse_move_permission"), do: :corpse_move_permission
    def from_json!("corpse_to_world"), do: :corpse_to_world
    def from_json!("free_grab"), do: :free_grab
    def from_json!("give_item"), do: :give_item
    def from_json!("kill"), do: :kill
    def from_json!("kill_credit"), do: :kill_credit
    def from_json!("leave_item"), do: :leave_item
    def from_json!("level_change"), do: :level_change
    def from_json!("loot"), do: :loot
    def from_json!("loot_do_roll"), do: :loot_do_roll
    def from_json!("resurrect"), do: :resurrect
    def from_json!("try_loot_item"), do: :try_loot_item
    def from_json!("udp_stats"), do: :udp_stats
    def from_json!("xp_change"), do: :xp_change

    @spec to_json!(t()) :: String.t()
    def to_json!(:aa_purchase), do: "aa_purchase"
    def to_json!(:achievement_progress), do: "achievement_progress"
    def to_json!(:add_looter), do: "add_looter"
    def to_json!(:calculate_master_looter), do: "calculate_master_looter"
    def to_json!(:corpse_create), do: "corpse_create"
    def to_json!(:corpse_dust), do: "corpse_dust"
    def to_json!(:corpse_from_world), do: "corpse_from_world"
    def to_json!(:corpse_lock), do: "corpse_lock"
    def to_json!(:corpse_move_permission), do: "corpse_move_permission"
    def to_json!(:corpse_to_world), do: "corpse_to_world"
    def to_json!(:free_grab), do: "free_grab"
    def to_json!(:give_item), do: "give_item"
    def to_json!(:kill), do: "kill"
    def to_json!(:kill_credit), do: "kill_credit"
    def to_json!(:leave_item), do: "leave_item"
    def to_json!(:level_change), do: "level_change"
    def to_json!(:loot), do: "loot"
    def to_json!(:loot_do_roll), do: "loot_do_roll"
    def to_json!(:resurrect), do: "resurrect"
    def to_json!(:try_loot_item), do: "try_loot_item"
    def to_json!(:udp_stats), do: "udp_stats"
    def to_json!(:xp_change), do: "xp_change"

  end

  defmodule AnalyticsEvent do

    @type t :: Analytics.AaPurchase.t() | Analytics.AchievementProgress.t() | Analytics.AddLooter.t() | Analytics.CalculateMasterLooter.t() | Analytics.CorpseCreate.t() | Analytics.CorpseDust.t() | Analytics.CorpseFromWorld.t() | Analytics.CorpseLock.t() | Analytics.CorpseMovePermission.t() | Analytics.CorpseToWorld.t() | Analytics.FreeGrab.t() | Analytics.GiveItem.t() | Analytics.Kill.t() | Analytics.KillCredit.t() | Analytics.LeaveItem.t() | Analytics.LevelChange.t() | Analytics.Loot.t() | Analytics.LootDoRoll.t() | Analytics.Resurrect.t() | Analytics.TryLootItem.t() | Analytics.UdpStats.t() | Analytics.XpChange.t()

    @spec from_json!(Igor.Json.json()) :: t() | no_return
    def from_json!(json) do
      tag = Igor.Json.parse_field!(json, "event_name", {:custom, Analytics.EventName})
      case tag do
        :aa_purchase -> Analytics.AaPurchase.from_json!(json)
        :achievement_progress -> Analytics.AchievementProgress.from_json!(json)
        :add_looter -> Analytics.AddLooter.from_json!(json)
        :calculate_master_looter -> Analytics.CalculateMasterLooter.from_json!(json)
        :corpse_create -> Analytics.CorpseCreate.from_json!(json)
        :corpse_dust -> Analytics.CorpseDust.from_json!(json)
        :corpse_from_world -> Analytics.CorpseFromWorld.from_json!(json)
        :corpse_lock -> Analytics.CorpseLock.from_json!(json)
        :corpse_move_permission -> Analytics.CorpseMovePermission.from_json!(json)
        :corpse_to_world -> Analytics.CorpseToWorld.from_json!(json)
        :free_grab -> Analytics.FreeGrab.from_json!(json)
        :give_item -> Analytics.GiveItem.from_json!(json)
        :kill -> Analytics.Kill.from_json!(json)
        :kill_credit -> Analytics.KillCredit.from_json!(json)
        :leave_item -> Analytics.LeaveItem.from_json!(json)
        :level_change -> Analytics.LevelChange.from_json!(json)
        :loot -> Analytics.Loot.from_json!(json)
        :loot_do_roll -> Analytics.LootDoRoll.from_json!(json)
        :resurrect -> Analytics.Resurrect.from_json!(json)
        :try_loot_item -> Analytics.TryLootItem.from_json!(json)
        :udp_stats -> Analytics.UdpStats.from_json!(json)
        :xp_change -> Analytics.XpChange.from_json!(json)
      end
    end

    @spec to_json!(t()) :: Igor.Json.json() | no_return
    def to_json!(struct) when is_struct(struct, Analytics.AaPurchase) do
      Analytics.AaPurchase.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.AchievementProgress) do
      Analytics.AchievementProgress.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.AddLooter) do
      Analytics.AddLooter.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CalculateMasterLooter) do
      Analytics.CalculateMasterLooter.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CorpseCreate) do
      Analytics.CorpseCreate.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CorpseDust) do
      Analytics.CorpseDust.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CorpseFromWorld) do
      Analytics.CorpseFromWorld.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CorpseLock) do
      Analytics.CorpseLock.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CorpseMovePermission) do
      Analytics.CorpseMovePermission.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.CorpseToWorld) do
      Analytics.CorpseToWorld.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.FreeGrab) do
      Analytics.FreeGrab.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.GiveItem) do
      Analytics.GiveItem.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.Kill) do
      Analytics.Kill.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.KillCredit) do
      Analytics.KillCredit.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.LeaveItem) do
      Analytics.LeaveItem.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.LevelChange) do
      Analytics.LevelChange.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.Loot) do
      Analytics.Loot.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.LootDoRoll) do
      Analytics.LootDoRoll.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.Resurrect) do
      Analytics.Resurrect.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.TryLootItem) do
      Analytics.TryLootItem.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.UdpStats) do
      Analytics.UdpStats.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, Analytics.XpChange) do
      Analytics.XpChange.to_json!(struct)
    end

  end

  defmodule AaPurchase do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :player_guid, :aa_id, :aa_cost, :pre_purchase_points, :post_purchase_points, :total_assigned_points_spent, :total_points_spent]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, player_guid: nil, aa_id: nil, aa_cost: nil, pre_purchase_points: nil, post_purchase_points: nil, total_assigned_points_spent: nil, total_points_spent: nil]

    @type t :: %AaPurchase{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, player_guid: integer, aa_id: integer, aa_cost: integer, pre_purchase_points: integer, post_purchase_points: integer, total_assigned_points_spent: integer, total_points_spent: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      player_guid = Igor.Json.parse_field!(json, "player_guid", :long)
      aa_id = Igor.Json.parse_field!(json, "aa_id", :int)
      aa_cost = Igor.Json.parse_field!(json, "aa_cost", :int)
      pre_purchase_points = Igor.Json.parse_field!(json, "pre_purchase_points", :int)
      post_purchase_points = Igor.Json.parse_field!(json, "post_purchase_points", :int)
      total_assigned_points_spent = Igor.Json.parse_field!(json, "total_assigned_points_spent", :int)
      total_points_spent = Igor.Json.parse_field!(json, "total_points_spent", :int)
      %AaPurchase{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        player_guid: player_guid,
        aa_id: aa_id,
        aa_cost: aa_cost,
        pre_purchase_points: pre_purchase_points,
        post_purchase_points: post_purchase_points,
        total_assigned_points_spent: total_assigned_points_spent,
        total_points_spent: total_points_spent
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        player_guid: player_guid,
        aa_id: aa_id,
        aa_cost: aa_cost,
        pre_purchase_points: pre_purchase_points,
        post_purchase_points: post_purchase_points,
        total_assigned_points_spent: total_assigned_points_spent,
        total_points_spent: total_points_spent
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:aa_purchase),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "player_guid" => Igor.Json.pack_value(player_guid, :long),
        "aa_id" => Igor.Json.pack_value(aa_id, :int),
        "aa_cost" => Igor.Json.pack_value(aa_cost, :int),
        "pre_purchase_points" => Igor.Json.pack_value(pre_purchase_points, :int),
        "post_purchase_points" => Igor.Json.pack_value(post_purchase_points, :int),
        "total_assigned_points_spent" => Igor.Json.pack_value(total_assigned_points_spent, :int),
        "total_points_spent" => Igor.Json.pack_value(total_points_spent, :int)
      }
    end

  end

  defmodule AchievementProgress do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :event_type, :object_name, :achievement_id, :component_id, :requirement_id, :requirement_type, :new_count]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, event_type: nil, object_name: nil, achievement_id: nil, component_id: nil, requirement_id: nil, requirement_type: nil, new_count: nil]

    @type t :: %AchievementProgress{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, event_type: atom, object_name: String.t(), achievement_id: integer, component_id: integer, requirement_id: integer, requirement_type: integer, new_count: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      event_type = Igor.Json.parse_field!(json, "event_type", :atom)
      object_name = Igor.Json.parse_field!(json, "object_name", :string)
      achievement_id = Igor.Json.parse_field!(json, "achievement_id", :long)
      component_id = Igor.Json.parse_field!(json, "component_id", :long)
      requirement_id = Igor.Json.parse_field!(json, "requirement_id", :long)
      requirement_type = Igor.Json.parse_field!(json, "requirement_type", :int)
      new_count = Igor.Json.parse_field!(json, "new_count", :long)
      %AchievementProgress{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        event_type: event_type,
        object_name: object_name,
        achievement_id: achievement_id,
        component_id: component_id,
        requirement_id: requirement_id,
        requirement_type: requirement_type,
        new_count: new_count
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        event_type: event_type,
        object_name: object_name,
        achievement_id: achievement_id,
        component_id: component_id,
        requirement_id: requirement_id,
        requirement_type: requirement_type,
        new_count: new_count
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:achievement_progress),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "event_type" => Igor.Json.pack_value(event_type, :atom),
        "object_name" => Igor.Json.pack_value(object_name, :string),
        "achievement_id" => Igor.Json.pack_value(achievement_id, :long),
        "component_id" => Igor.Json.pack_value(component_id, :long),
        "requirement_id" => Igor.Json.pack_value(requirement_id, :long),
        "requirement_type" => Igor.Json.pack_value(requirement_type, :int),
        "new_count" => Igor.Json.pack_value(new_count, :long)
      }
    end

  end

  defmodule AddLooter do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :player_type, :loot_name]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, player_type: nil, loot_name: nil, loot_distance: nil, is_new_loot_system: nil, is_looter_out_of_range: nil, is_looter_lost_access: nil, is_looter_dead: nil]

    @type t :: %AddLooter{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, player_type: atom, loot_name: String.t(), loot_distance: float | nil, is_new_loot_system: boolean | nil, is_looter_out_of_range: boolean | nil, is_looter_lost_access: boolean | nil, is_looter_dead: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      player_type = Igor.Json.parse_field!(json, "player_type", :atom)
      loot_name = Igor.Json.parse_field!(json, "loot_name", :string)
      loot_distance = Igor.Json.parse_field!(json, "loot_distance", :double, nil)
      is_new_loot_system = Igor.Json.parse_field!(json, "is_new_loot_system", :boolean, nil)
      is_looter_out_of_range = Igor.Json.parse_field!(json, "is_looter_out_of_range", :boolean, nil)
      is_looter_lost_access = Igor.Json.parse_field!(json, "is_looter_lost_access", :boolean, nil)
      is_looter_dead = Igor.Json.parse_field!(json, "is_looter_dead", :boolean, nil)
      %AddLooter{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        player_type: player_type,
        loot_name: loot_name,
        loot_distance: loot_distance,
        is_new_loot_system: is_new_loot_system,
        is_looter_out_of_range: is_looter_out_of_range,
        is_looter_lost_access: is_looter_lost_access,
        is_looter_dead: is_looter_dead
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        player_type: player_type,
        loot_name: loot_name,
        loot_distance: loot_distance,
        is_new_loot_system: is_new_loot_system,
        is_looter_out_of_range: is_looter_out_of_range,
        is_looter_lost_access: is_looter_lost_access,
        is_looter_dead: is_looter_dead
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :add_looter, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("player_sid", player_sid, :long)
        |> Igor.Json.pack_field("player_type", player_type, :atom)
        |> Igor.Json.pack_field("loot_name", loot_name, :string)
        |> Igor.Json.pack_field("loot_distance", loot_distance, :double)
        |> Igor.Json.pack_field("is_new_loot_system", is_new_loot_system, :boolean)
        |> Igor.Json.pack_field("is_looter_out_of_range", is_looter_out_of_range, :boolean)
        |> Igor.Json.pack_field("is_looter_lost_access", is_looter_lost_access, :boolean)
        |> Igor.Json.pack_field("is_looter_dead", is_looter_dead, :boolean)
    end

  end

  defmodule CalculateMasterLooter do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_id]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_id: nil, group_id: nil, raid_id: nil]

    @type t :: %CalculateMasterLooter{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_id: integer, group_id: integer | nil, raid_id: integer | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_id = Igor.Json.parse_field!(json, "loot_id", :long)
      group_id = Igor.Json.parse_field!(json, "group_id", :long, nil)
      raid_id = Igor.Json.parse_field!(json, "raid_id", :long, nil)
      %CalculateMasterLooter{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        group_id: group_id,
        raid_id: raid_id
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        group_id: group_id,
        raid_id: raid_id
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :calculate_master_looter, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("player_sid", player_sid, :long)
        |> Igor.Json.pack_field("loot_id", loot_id, :long)
        |> Igor.Json.pack_field("group_id", group_id, :long)
        |> Igor.Json.pack_field("raid_id", raid_id, :long)
    end

  end

  defmodule CorpseCreate do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :xp_corpse, :corpse_time_left, :corpse_x, :corpse_y, :corpse_z, :corpse_platinum, :corpse_gold, :corpse_silver, :corpse_copper]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, xp_corpse: nil, corpse_time_left: nil, corpse_x: nil, corpse_y: nil, corpse_z: nil, corpse_platinum: nil, corpse_gold: nil, corpse_silver: nil, corpse_copper: nil]

    @type t :: %CorpseCreate{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, xp_corpse: integer, corpse_time_left: integer, corpse_x: float, corpse_y: float, corpse_z: float, corpse_platinum: integer, corpse_gold: integer, corpse_silver: integer, corpse_copper: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      xp_corpse = Igor.Json.parse_field!(json, "xp_corpse", :long)
      corpse_time_left = Igor.Json.parse_field!(json, "corpse_time_left", :int)
      corpse_x = Igor.Json.parse_field!(json, "corpse_x", :double)
      corpse_y = Igor.Json.parse_field!(json, "corpse_y", :double)
      corpse_z = Igor.Json.parse_field!(json, "corpse_z", :double)
      corpse_platinum = Igor.Json.parse_field!(json, "corpse_platinum", :int)
      corpse_gold = Igor.Json.parse_field!(json, "corpse_gold", :int)
      corpse_silver = Igor.Json.parse_field!(json, "corpse_silver", :int)
      corpse_copper = Igor.Json.parse_field!(json, "corpse_copper", :int)
      %CorpseCreate{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        xp_corpse: xp_corpse,
        corpse_time_left: corpse_time_left,
        corpse_x: corpse_x,
        corpse_y: corpse_y,
        corpse_z: corpse_z,
        corpse_platinum: corpse_platinum,
        corpse_gold: corpse_gold,
        corpse_silver: corpse_silver,
        corpse_copper: corpse_copper
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        xp_corpse: xp_corpse,
        corpse_time_left: corpse_time_left,
        corpse_x: corpse_x,
        corpse_y: corpse_y,
        corpse_z: corpse_z,
        corpse_platinum: corpse_platinum,
        corpse_gold: corpse_gold,
        corpse_silver: corpse_silver,
        corpse_copper: corpse_copper
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:corpse_create),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "xp_corpse" => Igor.Json.pack_value(xp_corpse, :long),
        "corpse_time_left" => Igor.Json.pack_value(corpse_time_left, :int),
        "corpse_x" => Igor.Json.pack_value(corpse_x, :double),
        "corpse_y" => Igor.Json.pack_value(corpse_y, :double),
        "corpse_z" => Igor.Json.pack_value(corpse_z, :double),
        "corpse_platinum" => Igor.Json.pack_value(corpse_platinum, :int),
        "corpse_gold" => Igor.Json.pack_value(corpse_gold, :int),
        "corpse_silver" => Igor.Json.pack_value(corpse_silver, :int),
        "corpse_copper" => Igor.Json.pack_value(corpse_copper, :int)
      }
    end

  end

  defmodule CorpseDust do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, is_corpse_normal_looting: nil, is_corpse_empty: nil, xp_corpse: nil, is_corpse_pc_deleted: nil]

    @type t :: %CorpseDust{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, is_corpse_normal_looting: boolean | nil, is_corpse_empty: boolean | nil, xp_corpse: integer | nil, is_corpse_pc_deleted: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      is_corpse_normal_looting = Igor.Json.parse_field!(json, "is_corpse_normal_looting", :boolean, nil)
      is_corpse_empty = Igor.Json.parse_field!(json, "is_corpse_empty", :boolean, nil)
      xp_corpse = Igor.Json.parse_field!(json, "xp_corpse", :long, nil)
      is_corpse_pc_deleted = Igor.Json.parse_field!(json, "is_corpse_pc_deleted", :boolean, nil)
      %CorpseDust{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        is_corpse_normal_looting: is_corpse_normal_looting,
        is_corpse_empty: is_corpse_empty,
        xp_corpse: xp_corpse,
        is_corpse_pc_deleted: is_corpse_pc_deleted
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        is_corpse_normal_looting: is_corpse_normal_looting,
        is_corpse_empty: is_corpse_empty,
        xp_corpse: xp_corpse,
        is_corpse_pc_deleted: is_corpse_pc_deleted
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :corpse_dust, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("player_sid", player_sid, :long)
        |> Igor.Json.pack_field("is_corpse_normal_looting", is_corpse_normal_looting, :boolean)
        |> Igor.Json.pack_field("is_corpse_empty", is_corpse_empty, :boolean)
        |> Igor.Json.pack_field("xp_corpse", xp_corpse, :long)
        |> Igor.Json.pack_field("is_corpse_pc_deleted", is_corpse_pc_deleted, :boolean)
    end

  end

  defmodule CorpseFromWorld do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :xp_corpse, :corpse_x, :corpse_y, :corpse_z, :corpse_platinum, :corpse_gold, :corpse_silver, :corpse_copper]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, xp_corpse: nil, corpse_x: nil, corpse_y: nil, corpse_z: nil, corpse_platinum: nil, corpse_gold: nil, corpse_silver: nil, corpse_copper: nil]

    @type t :: %CorpseFromWorld{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), xp_corpse: integer, corpse_x: float, corpse_y: float, corpse_z: float, corpse_platinum: integer, corpse_gold: integer, corpse_silver: integer, corpse_copper: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      xp_corpse = Igor.Json.parse_field!(json, "xp_corpse", :long)
      corpse_x = Igor.Json.parse_field!(json, "corpse_x", :double)
      corpse_y = Igor.Json.parse_field!(json, "corpse_y", :double)
      corpse_z = Igor.Json.parse_field!(json, "corpse_z", :double)
      corpse_platinum = Igor.Json.parse_field!(json, "corpse_platinum", :int)
      corpse_gold = Igor.Json.parse_field!(json, "corpse_gold", :int)
      corpse_silver = Igor.Json.parse_field!(json, "corpse_silver", :int)
      corpse_copper = Igor.Json.parse_field!(json, "corpse_copper", :int)
      %CorpseFromWorld{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        xp_corpse: xp_corpse,
        corpse_x: corpse_x,
        corpse_y: corpse_y,
        corpse_z: corpse_z,
        corpse_platinum: corpse_platinum,
        corpse_gold: corpse_gold,
        corpse_silver: corpse_silver,
        corpse_copper: corpse_copper
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        xp_corpse: xp_corpse,
        corpse_x: corpse_x,
        corpse_y: corpse_y,
        corpse_z: corpse_z,
        corpse_platinum: corpse_platinum,
        corpse_gold: corpse_gold,
        corpse_silver: corpse_silver,
        corpse_copper: corpse_copper
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:corpse_from_world),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "xp_corpse" => Igor.Json.pack_value(xp_corpse, :long),
        "corpse_x" => Igor.Json.pack_value(corpse_x, :double),
        "corpse_y" => Igor.Json.pack_value(corpse_y, :double),
        "corpse_z" => Igor.Json.pack_value(corpse_z, :double),
        "corpse_platinum" => Igor.Json.pack_value(corpse_platinum, :int),
        "corpse_gold" => Igor.Json.pack_value(corpse_gold, :int),
        "corpse_silver" => Igor.Json.pack_value(corpse_silver, :int),
        "corpse_copper" => Igor.Json.pack_value(corpse_copper, :int)
      }
    end

  end

  defmodule CorpseLock do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :corpse_locker_name, :corpse_locker_sid]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, corpse_locker_name: nil, corpse_locker_sid: nil]

    @type t :: %CorpseLock{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, corpse_locker_name: String.t(), corpse_locker_sid: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      corpse_locker_name = Igor.Json.parse_field!(json, "corpse_locker_name", :string)
      corpse_locker_sid = Igor.Json.parse_field!(json, "corpse_locker_sid", :long)
      %CorpseLock{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        corpse_locker_name: corpse_locker_name,
        corpse_locker_sid: corpse_locker_sid
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        corpse_locker_name: corpse_locker_name,
        corpse_locker_sid: corpse_locker_sid
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:corpse_lock),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "corpse_locker_name" => Igor.Json.pack_value(corpse_locker_name, :string),
        "corpse_locker_sid" => Igor.Json.pack_value(corpse_locker_sid, :long)
      }
    end

  end

  defmodule CorpseMovePermission do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, group_id: nil, guild_guid: nil]

    @type t :: %CorpseMovePermission{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t() | nil, group_id: integer | nil, guild_guid: integer | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string, nil)
      group_id = Igor.Json.parse_field!(json, "group_id", :long, nil)
      guild_guid = Igor.Json.parse_field!(json, "guild_guid", :long, nil)
      %CorpseMovePermission{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        group_id: group_id,
        guild_guid: guild_guid
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        group_id: group_id,
        guild_guid: guild_guid
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :corpse_move_permission, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("group_id", group_id, :long)
        |> Igor.Json.pack_field("guild_guid", guild_guid, :long)
    end

  end

  defmodule CorpseToWorld do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil]

    @type t :: %CorpseToWorld{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      %CorpseToWorld{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:corpse_to_world),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long)
      }
    end

  end

  defmodule FreeGrab do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_id, :item_id, :luck, :transaction_id, :npc_id]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_id: nil, item_id: nil, luck: nil, transaction_id: nil, npc_id: nil]

    @type t :: %FreeGrab{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_id: integer, item_id: integer, luck: integer, transaction_id: integer, npc_id: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_id = Igor.Json.parse_field!(json, "loot_id", :long)
      item_id = Igor.Json.parse_field!(json, "item_id", :long)
      luck = Igor.Json.parse_field!(json, "luck", :int)
      transaction_id = Igor.Json.parse_field!(json, "transaction_id", :long)
      npc_id = Igor.Json.parse_field!(json, "npc_id", :long)
      %FreeGrab{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        item_id: item_id,
        luck: luck,
        transaction_id: transaction_id,
        npc_id: npc_id
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        item_id: item_id,
        luck: luck,
        transaction_id: transaction_id,
        npc_id: npc_id
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:free_grab),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "loot_id" => Igor.Json.pack_value(loot_id, :long),
        "item_id" => Igor.Json.pack_value(item_id, :long),
        "luck" => Igor.Json.pack_value(luck, :int),
        "transaction_id" => Igor.Json.pack_value(transaction_id, :long),
        "npc_id" => Igor.Json.pack_value(npc_id, :long)
      }
    end

  end

  defmodule GiveItem do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_id, :npc_id, :recipient_player_name, :recipient_player_sid, :count, :qty, :luck, :transaction_id, :is_item_left]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_id: nil, npc_id: nil, recipient_player_name: nil, recipient_player_sid: nil, count: nil, qty: nil, luck: nil, transaction_id: nil, is_item_left: nil]

    @type t :: %GiveItem{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_id: integer, npc_id: integer, recipient_player_name: String.t(), recipient_player_sid: integer, count: integer, qty: integer, luck: integer, transaction_id: integer, is_item_left: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_id = Igor.Json.parse_field!(json, "loot_id", :long)
      npc_id = Igor.Json.parse_field!(json, "npc_id", :long)
      recipient_player_name = Igor.Json.parse_field!(json, "recipient_player_name", :string)
      recipient_player_sid = Igor.Json.parse_field!(json, "recipient_player_sid", :long)
      count = Igor.Json.parse_field!(json, "count", :int)
      qty = Igor.Json.parse_field!(json, "qty", :int)
      luck = Igor.Json.parse_field!(json, "luck", :int)
      transaction_id = Igor.Json.parse_field!(json, "transaction_id", :long)
      is_item_left = Igor.Json.parse_field!(json, "is_item_left", :boolean)
      %GiveItem{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        npc_id: npc_id,
        recipient_player_name: recipient_player_name,
        recipient_player_sid: recipient_player_sid,
        count: count,
        qty: qty,
        luck: luck,
        transaction_id: transaction_id,
        is_item_left: is_item_left
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        npc_id: npc_id,
        recipient_player_name: recipient_player_name,
        recipient_player_sid: recipient_player_sid,
        count: count,
        qty: qty,
        luck: luck,
        transaction_id: transaction_id,
        is_item_left: is_item_left
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:give_item),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "loot_id" => Igor.Json.pack_value(loot_id, :long),
        "npc_id" => Igor.Json.pack_value(npc_id, :long),
        "recipient_player_name" => Igor.Json.pack_value(recipient_player_name, :string),
        "recipient_player_sid" => Igor.Json.pack_value(recipient_player_sid, :long),
        "count" => Igor.Json.pack_value(count, :int),
        "qty" => Igor.Json.pack_value(qty, :int),
        "luck" => Igor.Json.pack_value(luck, :int),
        "transaction_id" => Igor.Json.pack_value(transaction_id, :long),
        "is_item_left" => Igor.Json.pack_value(is_item_left, :boolean)
      }
    end

  end

  defmodule Kill do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :object_name, :killer_name]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, object_name: nil, killer_name: nil]

    @type t :: %Kill{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), object_name: String.t(), killer_name: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      object_name = Igor.Json.parse_field!(json, "object_name", :string)
      killer_name = Igor.Json.parse_field!(json, "killer_name", :string)
      %Kill{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        object_name: object_name,
        killer_name: killer_name
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        object_name: object_name,
        killer_name: killer_name
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:kill),
        "object_name" => Igor.Json.pack_value(object_name, :string),
        "killer_name" => Igor.Json.pack_value(killer_name, :string)
      }
    end

  end

  defmodule KillCredit do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :object_name]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, object_name: nil, overwritten_sid: nil, overwritten_name: nil, raid_id: nil, eligible_looters: nil]

    @type t :: %KillCredit{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, object_name: String.t(), overwritten_sid: integer | nil, overwritten_name: String.t() | nil, raid_id: integer | nil, eligible_looters: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      object_name = Igor.Json.parse_field!(json, "object_name", :string)
      overwritten_sid = Igor.Json.parse_field!(json, "overwritten_sid", :long, nil)
      overwritten_name = Igor.Json.parse_field!(json, "overwritten_name", :string, nil)
      raid_id = Igor.Json.parse_field!(json, "raid_id", :long, nil)
      eligible_looters = Igor.Json.parse_field!(json, "eligible_looters", :string, nil)
      %KillCredit{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        object_name: object_name,
        overwritten_sid: overwritten_sid,
        overwritten_name: overwritten_name,
        raid_id: raid_id,
        eligible_looters: eligible_looters
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        object_name: object_name,
        overwritten_sid: overwritten_sid,
        overwritten_name: overwritten_name,
        raid_id: raid_id,
        eligible_looters: eligible_looters
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :kill_credit, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("player_sid", player_sid, :long)
        |> Igor.Json.pack_field("object_name", object_name, :string)
        |> Igor.Json.pack_field("overwritten_sid", overwritten_sid, :long)
        |> Igor.Json.pack_field("overwritten_name", overwritten_name, :string)
        |> Igor.Json.pack_field("raid_id", raid_id, :long)
        |> Igor.Json.pack_field("eligible_looters", eligible_looters, :string)
    end

  end

  defmodule LeaveItem do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_id, :npc_id, :is_player_cheating]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_id: nil, npc_id: nil, is_player_cheating: nil, is_release_underflow: nil, is_corpse_missing: nil]

    @type t :: %LeaveItem{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_id: integer, npc_id: integer, is_player_cheating: boolean, is_release_underflow: boolean | nil, is_corpse_missing: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_id = Igor.Json.parse_field!(json, "loot_id", :long)
      npc_id = Igor.Json.parse_field!(json, "npc_id", :long)
      is_player_cheating = Igor.Json.parse_field!(json, "is_player_cheating", :boolean)
      is_release_underflow = Igor.Json.parse_field!(json, "is_release_underflow", :boolean, nil)
      is_corpse_missing = Igor.Json.parse_field!(json, "is_corpse_missing", :boolean, nil)
      %LeaveItem{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        npc_id: npc_id,
        is_player_cheating: is_player_cheating,
        is_release_underflow: is_release_underflow,
        is_corpse_missing: is_corpse_missing
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        npc_id: npc_id,
        is_player_cheating: is_player_cheating,
        is_release_underflow: is_release_underflow,
        is_corpse_missing: is_corpse_missing
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :leave_item, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("player_sid", player_sid, :long)
        |> Igor.Json.pack_field("loot_id", loot_id, :long)
        |> Igor.Json.pack_field("npc_id", npc_id, :long)
        |> Igor.Json.pack_field("is_player_cheating", is_player_cheating, :boolean)
        |> Igor.Json.pack_field("is_release_underflow", is_release_underflow, :boolean)
        |> Igor.Json.pack_field("is_corpse_missing", is_corpse_missing, :boolean)
    end

  end

  defmodule LevelChange do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :level, :race, :class, :guild_name, :guild_guid]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, level: nil, race: nil, class: nil, guild_name: nil, guild_guid: nil]

    @type t :: %LevelChange{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, level: integer, race: atom, class: atom, guild_name: String.t(), guild_guid: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      level = Igor.Json.parse_field!(json, "level", :int)
      race = Igor.Json.parse_field!(json, "race", :atom)
      class = Igor.Json.parse_field!(json, "class", :atom)
      guild_name = Igor.Json.parse_field!(json, "guild_name", :string)
      guild_guid = Igor.Json.parse_field!(json, "guild_guid", :long)
      %LevelChange{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        level: level,
        race: race,
        class: class,
        guild_name: guild_name,
        guild_guid: guild_guid
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        level: level,
        race: race,
        class: class,
        guild_name: guild_name,
        guild_guid: guild_guid
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:level_change),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "level" => Igor.Json.pack_value(level, :int),
        "race" => Igor.Json.pack_value(race, :atom),
        "class" => Igor.Json.pack_value(class, :atom),
        "guild_name" => Igor.Json.pack_value(guild_name, :string),
        "guild_guid" => Igor.Json.pack_value(guild_guid, :long)
      }
    end

  end

  defmodule Loot do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_count, :item_name, :item_id, :item_qty, :item_guid, :item_is_artifact, :loot_source, :loot_index_1, :loot_index_2, :loot_index_3, :loot_name]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_count: nil, item_name: nil, item_id: nil, item_qty: nil, item_guid: nil, item_is_artifact: nil, loot_source: nil, loot_index_1: nil, loot_index_2: nil, loot_index_3: nil, loot_name: nil]

    @type t :: %Loot{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_count: integer, item_name: String.t(), item_id: integer, item_qty: integer, item_guid: String.t(), item_is_artifact: boolean, loot_source: atom, loot_index_1: integer, loot_index_2: integer, loot_index_3: integer, loot_name: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_count = Igor.Json.parse_field!(json, "loot_count", :int)
      item_name = Igor.Json.parse_field!(json, "item_name", :string)
      item_id = Igor.Json.parse_field!(json, "item_id", :long)
      item_qty = Igor.Json.parse_field!(json, "item_qty", :int)
      item_guid = Igor.Json.parse_field!(json, "item_guid", :string)
      item_is_artifact = Igor.Json.parse_field!(json, "item_is_artifact", :boolean)
      loot_source = Igor.Json.parse_field!(json, "loot_source", :atom)
      loot_index_1 = Igor.Json.parse_field!(json, "loot_index_1", :int)
      loot_index_2 = Igor.Json.parse_field!(json, "loot_index_2", :int)
      loot_index_3 = Igor.Json.parse_field!(json, "loot_index_3", :int)
      loot_name = Igor.Json.parse_field!(json, "loot_name", :string)
      %Loot{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_count: loot_count,
        item_name: item_name,
        item_id: item_id,
        item_qty: item_qty,
        item_guid: item_guid,
        item_is_artifact: item_is_artifact,
        loot_source: loot_source,
        loot_index_1: loot_index_1,
        loot_index_2: loot_index_2,
        loot_index_3: loot_index_3,
        loot_name: loot_name
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_count: loot_count,
        item_name: item_name,
        item_id: item_id,
        item_qty: item_qty,
        item_guid: item_guid,
        item_is_artifact: item_is_artifact,
        loot_source: loot_source,
        loot_index_1: loot_index_1,
        loot_index_2: loot_index_2,
        loot_index_3: loot_index_3,
        loot_name: loot_name
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:loot),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "loot_count" => Igor.Json.pack_value(loot_count, :int),
        "item_name" => Igor.Json.pack_value(item_name, :string),
        "item_id" => Igor.Json.pack_value(item_id, :long),
        "item_qty" => Igor.Json.pack_value(item_qty, :int),
        "item_guid" => Igor.Json.pack_value(item_guid, :string),
        "item_is_artifact" => Igor.Json.pack_value(item_is_artifact, :boolean),
        "loot_source" => Igor.Json.pack_value(loot_source, :atom),
        "loot_index_1" => Igor.Json.pack_value(loot_index_1, :int),
        "loot_index_2" => Igor.Json.pack_value(loot_index_2, :int),
        "loot_index_3" => Igor.Json.pack_value(loot_index_3, :int),
        "loot_name" => Igor.Json.pack_value(loot_name, :string)
      }
    end

  end

  defmodule LootDoRoll do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_id, :recipient_player_name, :recipient_player_sid, :count, :qty, :luck, :transaction_id]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_id: nil, recipient_player_name: nil, recipient_player_sid: nil, count: nil, qty: nil, luck: nil, transaction_id: nil]

    @type t :: %LootDoRoll{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_id: integer, recipient_player_name: String.t(), recipient_player_sid: integer, count: integer, qty: integer, luck: integer, transaction_id: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_id = Igor.Json.parse_field!(json, "loot_id", :long)
      recipient_player_name = Igor.Json.parse_field!(json, "recipient_player_name", :string)
      recipient_player_sid = Igor.Json.parse_field!(json, "recipient_player_sid", :long)
      count = Igor.Json.parse_field!(json, "count", :int)
      qty = Igor.Json.parse_field!(json, "qty", :int)
      luck = Igor.Json.parse_field!(json, "luck", :int)
      transaction_id = Igor.Json.parse_field!(json, "transaction_id", :long)
      %LootDoRoll{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        recipient_player_name: recipient_player_name,
        recipient_player_sid: recipient_player_sid,
        count: count,
        qty: qty,
        luck: luck,
        transaction_id: transaction_id
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        recipient_player_name: recipient_player_name,
        recipient_player_sid: recipient_player_sid,
        count: count,
        qty: qty,
        luck: luck,
        transaction_id: transaction_id
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:loot_do_roll),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "loot_id" => Igor.Json.pack_value(loot_id, :long),
        "recipient_player_name" => Igor.Json.pack_value(recipient_player_name, :string),
        "recipient_player_sid" => Igor.Json.pack_value(recipient_player_sid, :long),
        "count" => Igor.Json.pack_value(count, :int),
        "qty" => Igor.Json.pack_value(qty, :int),
        "luck" => Igor.Json.pack_value(luck, :int),
        "transaction_id" => Igor.Json.pack_value(transaction_id, :long)
      }
    end

  end

  defmodule Resurrect do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :xp_back]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, xp_back: nil]

    @type t :: %Resurrect{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, xp_back: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      xp_back = Igor.Json.parse_field!(json, "xp_back", :long)
      %Resurrect{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        xp_back: xp_back
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        xp_back: xp_back
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:resurrect),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "xp_back" => Igor.Json.pack_value(xp_back, :long)
      }
    end

  end

  defmodule TryLootItem do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :loot_id, :npc_id]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, loot_id: nil, npc_id: nil, item_id: nil, luck: nil, is_item_sent: nil, is_corpse_missing: nil, is_player_cheating: nil]

    @type t :: %TryLootItem{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, loot_id: integer, npc_id: integer, item_id: integer | nil, luck: integer | nil, is_item_sent: boolean | nil, is_corpse_missing: boolean | nil, is_player_cheating: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      loot_id = Igor.Json.parse_field!(json, "loot_id", :long)
      npc_id = Igor.Json.parse_field!(json, "npc_id", :long)
      item_id = Igor.Json.parse_field!(json, "item_id", :long, nil)
      luck = Igor.Json.parse_field!(json, "luck", :int, nil)
      is_item_sent = Igor.Json.parse_field!(json, "is_item_sent", :boolean, nil)
      is_corpse_missing = Igor.Json.parse_field!(json, "is_corpse_missing", :boolean, nil)
      is_player_cheating = Igor.Json.parse_field!(json, "is_player_cheating", :boolean, nil)
      %TryLootItem{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        npc_id: npc_id,
        item_id: item_id,
        luck: luck,
        is_item_sent: is_item_sent,
        is_corpse_missing: is_corpse_missing,
        is_player_cheating: is_player_cheating
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        loot_id: loot_id,
        npc_id: npc_id,
        item_id: item_id,
        luck: luck,
        is_item_sent: is_item_sent,
        is_corpse_missing: is_corpse_missing,
        is_player_cheating: is_player_cheating
      } = args
      %{}
        |> Igor.Json.pack_field("datetime", datetime, :string)
        |> Igor.Json.pack_field("timestamp", timestamp, :ulong)
        |> Igor.Json.pack_field("zone", zone, :string)
        |> Igor.Json.pack_field("world", world, :atom)
        |> Igor.Json.pack_field("map", map, :string)
        |> Igor.Json.pack_field("event_name", :try_loot_item, {:custom, Analytics.EventName})
        |> Igor.Json.pack_field("player_name", player_name, :string)
        |> Igor.Json.pack_field("player_sid", player_sid, :long)
        |> Igor.Json.pack_field("loot_id", loot_id, :long)
        |> Igor.Json.pack_field("npc_id", npc_id, :long)
        |> Igor.Json.pack_field("item_id", item_id, :long)
        |> Igor.Json.pack_field("luck", luck, :int)
        |> Igor.Json.pack_field("is_item_sent", is_item_sent, :boolean)
        |> Igor.Json.pack_field("is_corpse_missing", is_corpse_missing, :boolean)
        |> Igor.Json.pack_field("is_player_cheating", is_player_cheating, :boolean)
    end

  end

  defmodule UdpStats do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :udp_iterations, :udp_last_cycle_iterations, :udp_last_cycle_duration, :udp_last_cycle_frequency, :udp_bytes_sent, :udp_packets_sent, :udp_bytes_received, :udp_packets_received, :udp_connection_requests, :udp_rejected_packets_crc, :udp_rejected_packets_order, :udp_rejected_packets_dup, :udp_rejected_packets_corrupt, :udp_resent_packets_accel, :udp_resent_packets_timeout, :udp_priority_queue_processed, :udp_priority_queue_possible, :udp_application_packets_sent, :udp_application_packets_received, :udp_overflow_errors, :udp_pool_created, :udp_pool_available]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, udp_iterations: nil, udp_last_cycle_iterations: nil, udp_last_cycle_duration: nil, udp_last_cycle_frequency: nil, udp_bytes_sent: nil, udp_packets_sent: nil, udp_bytes_received: nil, udp_packets_received: nil, udp_connection_requests: nil, udp_rejected_packets_crc: nil, udp_rejected_packets_order: nil, udp_rejected_packets_dup: nil, udp_rejected_packets_corrupt: nil, udp_resent_packets_accel: nil, udp_resent_packets_timeout: nil, udp_priority_queue_processed: nil, udp_priority_queue_possible: nil, udp_application_packets_sent: nil, udp_application_packets_received: nil, udp_overflow_errors: nil, udp_pool_created: nil, udp_pool_available: nil]

    @type t :: %UdpStats{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), udp_iterations: integer, udp_last_cycle_iterations: integer, udp_last_cycle_duration: integer, udp_last_cycle_frequency: float, udp_bytes_sent: integer, udp_packets_sent: integer, udp_bytes_received: integer, udp_packets_received: integer, udp_connection_requests: integer, udp_rejected_packets_crc: integer, udp_rejected_packets_order: integer, udp_rejected_packets_dup: integer, udp_rejected_packets_corrupt: integer, udp_resent_packets_accel: integer, udp_resent_packets_timeout: integer, udp_priority_queue_processed: integer, udp_priority_queue_possible: integer, udp_application_packets_sent: integer, udp_application_packets_received: integer, udp_overflow_errors: integer, udp_pool_created: integer, udp_pool_available: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      udp_iterations = Igor.Json.parse_field!(json, "udp_iterations", :long)
      udp_last_cycle_iterations = Igor.Json.parse_field!(json, "udp_last_cycle_iterations", :long)
      udp_last_cycle_duration = Igor.Json.parse_field!(json, "udp_last_cycle_duration", :long)
      udp_last_cycle_frequency = Igor.Json.parse_field!(json, "udp_last_cycle_frequency", :double)
      udp_bytes_sent = Igor.Json.parse_field!(json, "udp_bytes_sent", :long)
      udp_packets_sent = Igor.Json.parse_field!(json, "udp_packets_sent", :long)
      udp_bytes_received = Igor.Json.parse_field!(json, "udp_bytes_received", :long)
      udp_packets_received = Igor.Json.parse_field!(json, "udp_packets_received", :long)
      udp_connection_requests = Igor.Json.parse_field!(json, "udp_connection_requests", :long)
      udp_rejected_packets_crc = Igor.Json.parse_field!(json, "udp_rejected_packets_crc", :long)
      udp_rejected_packets_order = Igor.Json.parse_field!(json, "udp_rejected_packets_order", :long)
      udp_rejected_packets_dup = Igor.Json.parse_field!(json, "udp_rejected_packets_dup", :long)
      udp_rejected_packets_corrupt = Igor.Json.parse_field!(json, "udp_rejected_packets_corrupt", :long)
      udp_resent_packets_accel = Igor.Json.parse_field!(json, "udp_resent_packets_accel", :long)
      udp_resent_packets_timeout = Igor.Json.parse_field!(json, "udp_resent_packets_timeout", :long)
      udp_priority_queue_processed = Igor.Json.parse_field!(json, "udp_priority_queue_processed", :long)
      udp_priority_queue_possible = Igor.Json.parse_field!(json, "udp_priority_queue_possible", :long)
      udp_application_packets_sent = Igor.Json.parse_field!(json, "udp_application_packets_sent", :long)
      udp_application_packets_received = Igor.Json.parse_field!(json, "udp_application_packets_received", :long)
      udp_overflow_errors = Igor.Json.parse_field!(json, "udp_overflow_errors", :long)
      udp_pool_created = Igor.Json.parse_field!(json, "udp_pool_created", :long)
      udp_pool_available = Igor.Json.parse_field!(json, "udp_pool_available", :long)
      %UdpStats{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        udp_iterations: udp_iterations,
        udp_last_cycle_iterations: udp_last_cycle_iterations,
        udp_last_cycle_duration: udp_last_cycle_duration,
        udp_last_cycle_frequency: udp_last_cycle_frequency,
        udp_bytes_sent: udp_bytes_sent,
        udp_packets_sent: udp_packets_sent,
        udp_bytes_received: udp_bytes_received,
        udp_packets_received: udp_packets_received,
        udp_connection_requests: udp_connection_requests,
        udp_rejected_packets_crc: udp_rejected_packets_crc,
        udp_rejected_packets_order: udp_rejected_packets_order,
        udp_rejected_packets_dup: udp_rejected_packets_dup,
        udp_rejected_packets_corrupt: udp_rejected_packets_corrupt,
        udp_resent_packets_accel: udp_resent_packets_accel,
        udp_resent_packets_timeout: udp_resent_packets_timeout,
        udp_priority_queue_processed: udp_priority_queue_processed,
        udp_priority_queue_possible: udp_priority_queue_possible,
        udp_application_packets_sent: udp_application_packets_sent,
        udp_application_packets_received: udp_application_packets_received,
        udp_overflow_errors: udp_overflow_errors,
        udp_pool_created: udp_pool_created,
        udp_pool_available: udp_pool_available
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        udp_iterations: udp_iterations,
        udp_last_cycle_iterations: udp_last_cycle_iterations,
        udp_last_cycle_duration: udp_last_cycle_duration,
        udp_last_cycle_frequency: udp_last_cycle_frequency,
        udp_bytes_sent: udp_bytes_sent,
        udp_packets_sent: udp_packets_sent,
        udp_bytes_received: udp_bytes_received,
        udp_packets_received: udp_packets_received,
        udp_connection_requests: udp_connection_requests,
        udp_rejected_packets_crc: udp_rejected_packets_crc,
        udp_rejected_packets_order: udp_rejected_packets_order,
        udp_rejected_packets_dup: udp_rejected_packets_dup,
        udp_rejected_packets_corrupt: udp_rejected_packets_corrupt,
        udp_resent_packets_accel: udp_resent_packets_accel,
        udp_resent_packets_timeout: udp_resent_packets_timeout,
        udp_priority_queue_processed: udp_priority_queue_processed,
        udp_priority_queue_possible: udp_priority_queue_possible,
        udp_application_packets_sent: udp_application_packets_sent,
        udp_application_packets_received: udp_application_packets_received,
        udp_overflow_errors: udp_overflow_errors,
        udp_pool_created: udp_pool_created,
        udp_pool_available: udp_pool_available
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:udp_stats),
        "udp_iterations" => Igor.Json.pack_value(udp_iterations, :long),
        "udp_last_cycle_iterations" => Igor.Json.pack_value(udp_last_cycle_iterations, :long),
        "udp_last_cycle_duration" => Igor.Json.pack_value(udp_last_cycle_duration, :long),
        "udp_last_cycle_frequency" => Igor.Json.pack_value(udp_last_cycle_frequency, :double),
        "udp_bytes_sent" => Igor.Json.pack_value(udp_bytes_sent, :long),
        "udp_packets_sent" => Igor.Json.pack_value(udp_packets_sent, :long),
        "udp_bytes_received" => Igor.Json.pack_value(udp_bytes_received, :long),
        "udp_packets_received" => Igor.Json.pack_value(udp_packets_received, :long),
        "udp_connection_requests" => Igor.Json.pack_value(udp_connection_requests, :long),
        "udp_rejected_packets_crc" => Igor.Json.pack_value(udp_rejected_packets_crc, :long),
        "udp_rejected_packets_order" => Igor.Json.pack_value(udp_rejected_packets_order, :long),
        "udp_rejected_packets_dup" => Igor.Json.pack_value(udp_rejected_packets_dup, :long),
        "udp_rejected_packets_corrupt" => Igor.Json.pack_value(udp_rejected_packets_corrupt, :long),
        "udp_resent_packets_accel" => Igor.Json.pack_value(udp_resent_packets_accel, :long),
        "udp_resent_packets_timeout" => Igor.Json.pack_value(udp_resent_packets_timeout, :long),
        "udp_priority_queue_processed" => Igor.Json.pack_value(udp_priority_queue_processed, :long),
        "udp_priority_queue_possible" => Igor.Json.pack_value(udp_priority_queue_possible, :long),
        "udp_application_packets_sent" => Igor.Json.pack_value(udp_application_packets_sent, :long),
        "udp_application_packets_received" => Igor.Json.pack_value(udp_application_packets_received, :long),
        "udp_overflow_errors" => Igor.Json.pack_value(udp_overflow_errors, :long),
        "udp_pool_created" => Igor.Json.pack_value(udp_pool_created, :long),
        "udp_pool_available" => Igor.Json.pack_value(udp_pool_available, :long)
      }
    end

  end

  defmodule XpChange do

    @enforce_keys [:datetime, :timestamp, :zone, :world, :map, :player_name, :player_sid, :player_guid, :xp_since_last_log, :xp_type, :xp_total, :aa_points_p, :level_p, :xp_last_profile_type]
    defstruct [datetime: nil, timestamp: nil, zone: nil, world: nil, map: nil, player_name: nil, player_sid: nil, player_guid: nil, xp_since_last_log: nil, xp_type: nil, xp_total: nil, aa_points_p: nil, level_p: nil, xp_last_profile_type: nil]

    @type t :: %XpChange{datetime: Analytics.date_time(), timestamp: Analytics.date_time64(), zone: String.t(), world: atom, map: String.t(), player_name: String.t(), player_sid: integer, player_guid: integer, xp_since_last_log: integer, xp_type: integer, xp_total: integer, aa_points_p: float, level_p: float, xp_last_profile_type: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      datetime = Igor.Json.parse_field!(json, "datetime", :string)
      timestamp = Igor.Json.parse_field!(json, "timestamp", :ulong)
      zone = Igor.Json.parse_field!(json, "zone", :string)
      world = Igor.Json.parse_field!(json, "world", :atom)
      map = Igor.Json.parse_field!(json, "map", :string)
      player_name = Igor.Json.parse_field!(json, "player_name", :string)
      player_sid = Igor.Json.parse_field!(json, "player_sid", :long)
      player_guid = Igor.Json.parse_field!(json, "player_guid", :long)
      xp_since_last_log = Igor.Json.parse_field!(json, "xp_since_last_log", :long)
      xp_type = Igor.Json.parse_field!(json, "xp_type", :int)
      xp_total = Igor.Json.parse_field!(json, "xp_total", :long)
      aa_points_p = Igor.Json.parse_field!(json, "aa_points_p", :double)
      level_p = Igor.Json.parse_field!(json, "level_p", :double)
      xp_last_profile_type = Igor.Json.parse_field!(json, "xp_last_profile_type", :int)
      %XpChange{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        player_guid: player_guid,
        xp_since_last_log: xp_since_last_log,
        xp_type: xp_type,
        xp_total: xp_total,
        aa_points_p: aa_points_p,
        level_p: level_p,
        xp_last_profile_type: xp_last_profile_type
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        datetime: datetime,
        timestamp: timestamp,
        zone: zone,
        world: world,
        map: map,
        player_name: player_name,
        player_sid: player_sid,
        player_guid: player_guid,
        xp_since_last_log: xp_since_last_log,
        xp_type: xp_type,
        xp_total: xp_total,
        aa_points_p: aa_points_p,
        level_p: level_p,
        xp_last_profile_type: xp_last_profile_type
      } = args
      %{
        "datetime" => Igor.Json.pack_value(datetime, :string),
        "timestamp" => Igor.Json.pack_value(timestamp, :ulong),
        "zone" => Igor.Json.pack_value(zone, :string),
        "world" => Igor.Json.pack_value(world, :atom),
        "map" => Igor.Json.pack_value(map, :string),
        "event_name" => Analytics.EventName.to_json!(:xp_change),
        "player_name" => Igor.Json.pack_value(player_name, :string),
        "player_sid" => Igor.Json.pack_value(player_sid, :long),
        "player_guid" => Igor.Json.pack_value(player_guid, :long),
        "xp_since_last_log" => Igor.Json.pack_value(xp_since_last_log, :long),
        "xp_type" => Igor.Json.pack_value(xp_type, :int),
        "xp_total" => Igor.Json.pack_value(xp_total, :long),
        "aa_points_p" => Igor.Json.pack_value(aa_points_p, :double),
        "level_p" => Igor.Json.pack_value(level_p, :double),
        "xp_last_profile_type" => Igor.Json.pack_value(xp_last_profile_type, :int)
      }
    end

  end

  @type date_time :: String.t()

  @type date_time64 :: non_neg_integer

end
