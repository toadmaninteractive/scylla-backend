# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule ClickhouseProtocol do

  defmodule DataType do

    @type t ::
      :int8 #
    | :int16 #
    | :int32 #
    | :int64 #
    | :uint8 #
    | :uint16 #
    | :uint32 #
    | :uint64 #
    | :float32 #
    | :float64 #
    | :decimal #
    | :decimal32 #
    | :decimal64 #
    | :decimal128 #
    | :string #
    | :fixed_string #
    | :uuid #
    | :date #
    | :date_time #
    | :enum8 #
    | :enum16 #
    | :array #
    | :aggregate_function #
    | :tuple #
    | :special #

    defguard is_data_type(value) when value === :int8 or value === :int16 or value === :int32 or value === :int64 or value === :uint8 or value === :uint16 or value === :uint32 or value === :uint64 or value === :float32 or value === :float64 or value === :decimal or value === :decimal32 or value === :decimal64 or value === :decimal128 or value === :string or value === :fixed_string or value === :uuid or value === :date or value === :date_time or value === :enum8 or value === :enum16 or value === :array or value === :aggregate_function or value === :tuple or value === :special

    @spec from_json!(String.t()) :: t()
    def from_json!("int8"), do: :int8
    def from_json!("int16"), do: :int16
    def from_json!("int32"), do: :int32
    def from_json!("int64"), do: :int64
    def from_json!("uint8"), do: :uint8
    def from_json!("uint16"), do: :uint16
    def from_json!("uint32"), do: :uint32
    def from_json!("uint64"), do: :uint64
    def from_json!("float32"), do: :float32
    def from_json!("float64"), do: :float64
    def from_json!("decimal"), do: :decimal
    def from_json!("decimal32"), do: :decimal32
    def from_json!("decimal64"), do: :decimal64
    def from_json!("decimal128"), do: :decimal128
    def from_json!("string"), do: :string
    def from_json!("fixed_string"), do: :fixed_string
    def from_json!("uuid"), do: :uuid
    def from_json!("date"), do: :date
    def from_json!("date_time"), do: :date_time
    def from_json!("enum8"), do: :enum8
    def from_json!("enum16"), do: :enum16
    def from_json!("array"), do: :array
    def from_json!("aggregate_function"), do: :aggregate_function
    def from_json!("tuple"), do: :tuple
    def from_json!("special"), do: :special

    @spec to_json!(t()) :: String.t()
    def to_json!(:int8), do: "int8"
    def to_json!(:int16), do: "int16"
    def to_json!(:int32), do: "int32"
    def to_json!(:int64), do: "int64"
    def to_json!(:uint8), do: "uint8"
    def to_json!(:uint16), do: "uint16"
    def to_json!(:uint32), do: "uint32"
    def to_json!(:uint64), do: "uint64"
    def to_json!(:float32), do: "float32"
    def to_json!(:float64), do: "float64"
    def to_json!(:decimal), do: "decimal"
    def to_json!(:decimal32), do: "decimal32"
    def to_json!(:decimal64), do: "decimal64"
    def to_json!(:decimal128), do: "decimal128"
    def to_json!(:string), do: "string"
    def to_json!(:fixed_string), do: "fixed_string"
    def to_json!(:uuid), do: "uuid"
    def to_json!(:date), do: "date"
    def to_json!(:date_time), do: "date_time"
    def to_json!(:enum8), do: "enum8"
    def to_json!(:enum16), do: "enum16"
    def to_json!(:array), do: "array"
    def to_json!(:aggregate_function), do: "aggregate_function"
    def to_json!(:tuple), do: "tuple"
    def to_json!(:special), do: "special"

  end

  defmodule EnumPair do

    @enforce_keys [:key, :value]
    defstruct [key: nil, value: nil]

    @type t :: %EnumPair{key: String.t(), value: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      key = Igor.Json.parse_field!(json, "key", :string)
      value = Igor.Json.parse_field!(json, "value", :int)
      %EnumPair{key: key, value: value}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{key: key, value: value} = args
      %{
        "key" => Igor.Json.pack_value(key, :string),
        "value" => Igor.Json.pack_value(value, :int)
      }
    end

  end

  defmodule TypeSpec do

    defstruct [raw_spec: "", data_type: :special, nullable: false, enum_items: nil, decimal_precision: nil, decimal_scale: nil, fixed_string_length: nil, array_item_type: nil, tuple_item_types: nil]

    @type t :: %TypeSpec{raw_spec: String.t(), data_type: ClickhouseProtocol.DataType.t(), nullable: boolean, enum_items: [ClickhouseProtocol.EnumPair.t()] | nil, decimal_precision: integer | nil, decimal_scale: integer | nil, fixed_string_length: integer | nil, array_item_type: ClickhouseProtocol.TypeSpec.t() | nil, tuple_item_types: [ClickhouseProtocol.TypeSpec.t()] | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      raw_spec = Igor.Json.parse_field!(json, "raw_spec", :string, "")
      data_type = Igor.Json.parse_field!(json, "data_type", {:custom, ClickhouseProtocol.DataType}, :special)
      nullable = Igor.Json.parse_field!(json, "nullable", :boolean, false)
      enum_items = Igor.Json.parse_field!(json, "enum_items", {:list, {:custom, ClickhouseProtocol.EnumPair}}, nil)
      decimal_precision = Igor.Json.parse_field!(json, "decimal_precision", :int, nil)
      decimal_scale = Igor.Json.parse_field!(json, "decimal_scale", :int, nil)
      fixed_string_length = Igor.Json.parse_field!(json, "fixed_string_length", :int, nil)
      array_item_type = Igor.Json.parse_field!(json, "array_item_type", {:custom, ClickhouseProtocol.TypeSpec}, nil)
      tuple_item_types = Igor.Json.parse_field!(json, "tuple_item_types", {:list, {:custom, ClickhouseProtocol.TypeSpec}}, nil)
      %TypeSpec{
        raw_spec: raw_spec,
        data_type: data_type,
        nullable: nullable,
        enum_items: enum_items,
        decimal_precision: decimal_precision,
        decimal_scale: decimal_scale,
        fixed_string_length: fixed_string_length,
        array_item_type: array_item_type,
        tuple_item_types: tuple_item_types
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        raw_spec: raw_spec,
        data_type: data_type,
        nullable: nullable,
        enum_items: enum_items,
        decimal_precision: decimal_precision,
        decimal_scale: decimal_scale,
        fixed_string_length: fixed_string_length,
        array_item_type: array_item_type,
        tuple_item_types: tuple_item_types
      } = args
      %{}
        |> Igor.Json.pack_field("raw_spec", raw_spec, :string)
        |> Igor.Json.pack_field("data_type", data_type, {:custom, ClickhouseProtocol.DataType})
        |> Igor.Json.pack_field("nullable", nullable, :boolean)
        |> Igor.Json.pack_field("enum_items", enum_items, {:list, {:custom, ClickhouseProtocol.EnumPair}})
        |> Igor.Json.pack_field("decimal_precision", decimal_precision, :int)
        |> Igor.Json.pack_field("decimal_scale", decimal_scale, :int)
        |> Igor.Json.pack_field("fixed_string_length", fixed_string_length, :int)
        |> Igor.Json.pack_field("array_item_type", array_item_type, {:custom, ClickhouseProtocol.TypeSpec})
        |> Igor.Json.pack_field("tuple_item_types", tuple_item_types, {:list, {:custom, ClickhouseProtocol.TypeSpec}})
    end

  end

  defmodule ColumnDef do

    @enforce_keys [:name, :type]
    defstruct [name: nil, type: nil]

    @type t :: %ColumnDef{name: String.t(), type: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      name = Igor.Json.parse_field!(json, "name", :string)
      type = Igor.Json.parse_field!(json, "type", :string)
      %ColumnDef{name: name, type: type}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{name: name, type: type} = args
      %{
        "name" => Igor.Json.pack_value(name, :string),
        "type" => Igor.Json.pack_value(type, :string)
      }
    end

  end

  defmodule QueryStatistics do

    @enforce_keys [:elapsed, :rows_read, :bytes_read]
    defstruct [elapsed: nil, rows_read: nil, bytes_read: nil]

    @type t :: %QueryStatistics{elapsed: float, rows_read: integer, bytes_read: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      elapsed = Igor.Json.parse_field!(json, "elapsed", :double)
      rows_read = Igor.Json.parse_field!(json, "rows_read", :long)
      bytes_read = Igor.Json.parse_field!(json, "bytes_read", :long)
      %QueryStatistics{elapsed: elapsed, rows_read: rows_read, bytes_read: bytes_read}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{elapsed: elapsed, rows_read: rows_read, bytes_read: bytes_read} = args
      %{
        "elapsed" => Igor.Json.pack_value(elapsed, :double),
        "rows_read" => Igor.Json.pack_value(rows_read, :long),
        "bytes_read" => Igor.Json.pack_value(bytes_read, :long)
      }
    end

  end

  defmodule QueryResult do

    @enforce_keys [:meta, :data, :rows, :statistics]
    defstruct [meta: nil, data: nil, rows: nil, rows_before_limit_at_least: nil, statistics: nil]

    @type t :: %QueryResult{meta: [ClickhouseProtocol.ColumnDef.t()], data: [Igor.Json.json()], rows: integer, rows_before_limit_at_least: integer | nil, statistics: ClickhouseProtocol.QueryStatistics.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      meta = Igor.Json.parse_field!(json, "meta", {:list, {:custom, ClickhouseProtocol.ColumnDef}})
      data = Igor.Json.parse_field!(json, "data", {:list, :json})
      rows = Igor.Json.parse_field!(json, "rows", :long)
      rows_before_limit_at_least = Igor.Json.parse_field!(json, "rows_before_limit_at_least", :long, nil)
      statistics = Igor.Json.parse_field!(json, "statistics", {:custom, ClickhouseProtocol.QueryStatistics})
      %QueryResult{
        meta: meta,
        data: data,
        rows: rows,
        rows_before_limit_at_least: rows_before_limit_at_least,
        statistics: statistics
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        meta: meta,
        data: data,
        rows: rows,
        rows_before_limit_at_least: rows_before_limit_at_least,
        statistics: statistics
      } = args
      %{}
        |> Igor.Json.pack_field("meta", meta, {:list, {:custom, ClickhouseProtocol.ColumnDef}})
        |> Igor.Json.pack_field("data", data, {:list, :json})
        |> Igor.Json.pack_field("rows", rows, :long)
        |> Igor.Json.pack_field("rows_before_limit_at_least", rows_before_limit_at_least, :long)
        |> Igor.Json.pack_field("statistics", statistics, {:custom, ClickhouseProtocol.QueryStatistics})
    end

  end

  defmodule ClickhouseApi do

    @spec post_data(String.t(), String.t(), String.t(), String.t(), String.t(), String.t()) :: String.t()
    def post_data(base_url, request_content, username, password, database, sql_query) do
      query = Igor.Http.compose_query([{"user", username, :string}, {"password", password, :string}, {"database", database, :string}, {"query", sql_query, :string}])
      request_headers = [{"content-type", "text/plain"}]
      request_body = request_content
        |> Igor.Strings.format(:string)
      url = "#{base_url}/?#{query}"
      case HTTPoison.post(url, request_body, request_headers, [recv_timeout: 300000]) do
        {:ok, %HTTPoison.Response{status_code: status_code, body: body}} when status_code < 300 ->
          body
            |> Igor.Strings.parse!(:string)
        {:ok, %HTTPoison.Response{status_code: status_code, body: response_body, headers: response_headers}} ->
          raise %Igor.Http.HttpError{status_code: status_code, body: response_body, headers: response_headers}
        {:error, %HTTPoison.Error{reason: _} = e} ->
          raise e
      end
    end

  end

end
