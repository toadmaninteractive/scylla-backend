# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule IgorSchema do

  defmodule DescriptorKind do

    @type t ::
      :bool #
    | :int #
    | :float #
    | :string #
    | :binary #
    | :list #
    | :dict #
    | :enum #
    | :record #
    | :union #
    | :key #
    | :localized #
    | :datetime #
    | :json #
    | :custom #
    | :generic_instance #
    | :generic_argument #

    defguard is_descriptor_kind(value) when value === :bool or value === :int or value === :float or value === :string or value === :binary or value === :list or value === :dict or value === :enum or value === :record or value === :union or value === :key or value === :localized or value === :datetime or value === :json or value === :custom or value === :generic_instance or value === :generic_argument

    @spec from_string!(String.t()) :: t()
    def from_string!("bool"), do: :bool
    def from_string!("int"), do: :int
    def from_string!("float"), do: :float
    def from_string!("string"), do: :string
    def from_string!("binary"), do: :binary
    def from_string!("list"), do: :list
    def from_string!("dict"), do: :dict
    def from_string!("enum"), do: :enum
    def from_string!("record"), do: :record
    def from_string!("union"), do: :union
    def from_string!("key"), do: :key
    def from_string!("localized"), do: :localized
    def from_string!("datetime"), do: :datetime
    def from_string!("json"), do: :json
    def from_string!("custom"), do: :custom
    def from_string!("generic_instance"), do: :generic_instance
    def from_string!("generic_argument"), do: :generic_argument

    @spec to_string!(t()) :: String.t()
    def to_string!(:bool), do: "bool"
    def to_string!(:int), do: "int"
    def to_string!(:float), do: "float"
    def to_string!(:string), do: "string"
    def to_string!(:binary), do: "binary"
    def to_string!(:list), do: "list"
    def to_string!(:dict), do: "dict"
    def to_string!(:enum), do: "enum"
    def to_string!(:record), do: "record"
    def to_string!(:union), do: "union"
    def to_string!(:key), do: "key"
    def to_string!(:localized), do: "localized"
    def to_string!(:datetime), do: "datetime"
    def to_string!(:json), do: "json"
    def to_string!(:custom), do: "custom"
    def to_string!(:generic_instance), do: "generic_instance"
    def to_string!(:generic_argument), do: "generic_argument"

    @spec from_json!(String.t()) :: t()
    def from_json!("bool"), do: :bool
    def from_json!("int"), do: :int
    def from_json!("float"), do: :float
    def from_json!("string"), do: :string
    def from_json!("binary"), do: :binary
    def from_json!("list"), do: :list
    def from_json!("dict"), do: :dict
    def from_json!("enum"), do: :enum
    def from_json!("record"), do: :record
    def from_json!("union"), do: :union
    def from_json!("key"), do: :key
    def from_json!("localized"), do: :localized
    def from_json!("datetime"), do: :datetime
    def from_json!("json"), do: :json
    def from_json!("custom"), do: :custom
    def from_json!("generic_instance"), do: :generic_instance
    def from_json!("generic_argument"), do: :generic_argument

    @spec to_json!(t()) :: String.t()
    def to_json!(:bool), do: "bool"
    def to_json!(:int), do: "int"
    def to_json!(:float), do: "float"
    def to_json!(:string), do: "string"
    def to_json!(:binary), do: "binary"
    def to_json!(:list), do: "list"
    def to_json!(:dict), do: "dict"
    def to_json!(:enum), do: "enum"
    def to_json!(:record), do: "record"
    def to_json!(:union), do: "union"
    def to_json!(:key), do: "key"
    def to_json!(:localized), do: "localized"
    def to_json!(:datetime), do: "datetime"
    def to_json!(:json), do: "json"
    def to_json!(:custom), do: "custom"
    def to_json!(:generic_instance), do: "generic_instance"
    def to_json!(:generic_argument), do: "generic_argument"

  end

  defmodule Descriptor do

    @type t :: IgorSchema.BoolDescriptor.t() | IgorSchema.IntDescriptor.t() | IgorSchema.FloatDescriptor.t() | IgorSchema.StringDescriptor.t() | IgorSchema.BinaryDescriptor.t() | IgorSchema.ListDescriptor.t() | IgorSchema.DictDescriptor.t() | IgorSchema.EnumDescriptor.t() | IgorSchema.RecordDescriptor.t() | IgorSchema.UnionDescriptor.t() | IgorSchema.KeyDescriptor.t() | IgorSchema.LocalizedDescriptor.t() | IgorSchema.DateTimeDescriptor.t() | IgorSchema.JsonDescriptor.t() | IgorSchema.CustomDescriptor.t() | IgorSchema.GenericInstanceDescriptor.t() | IgorSchema.GenericArgumentDescriptor.t()

    @spec from_json!(Igor.Json.json()) :: t() | no_return
    def from_json!(json) do
      tag = Igor.Json.parse_field!(json, "kind", {:custom, IgorSchema.DescriptorKind})
      case tag do
        :bool -> IgorSchema.BoolDescriptor.from_json!(json)
        :int -> IgorSchema.IntDescriptor.from_json!(json)
        :float -> IgorSchema.FloatDescriptor.from_json!(json)
        :string -> IgorSchema.StringDescriptor.from_json!(json)
        :binary -> IgorSchema.BinaryDescriptor.from_json!(json)
        :list -> IgorSchema.ListDescriptor.from_json!(json)
        :dict -> IgorSchema.DictDescriptor.from_json!(json)
        :enum -> IgorSchema.EnumDescriptor.from_json!(json)
        :record -> IgorSchema.RecordDescriptor.from_json!(json)
        :union -> IgorSchema.UnionDescriptor.from_json!(json)
        :key -> IgorSchema.KeyDescriptor.from_json!(json)
        :localized -> IgorSchema.LocalizedDescriptor.from_json!(json)
        :datetime -> IgorSchema.DateTimeDescriptor.from_json!(json)
        :json -> IgorSchema.JsonDescriptor.from_json!(json)
        :custom -> IgorSchema.CustomDescriptor.from_json!(json)
        :generic_instance -> IgorSchema.GenericInstanceDescriptor.from_json!(json)
        :generic_argument -> IgorSchema.GenericArgumentDescriptor.from_json!(json)
      end
    end

    @spec to_json!(t()) :: Igor.Json.json() | no_return
    def to_json!(struct) when is_struct(struct, IgorSchema.BoolDescriptor) do
      IgorSchema.BoolDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.IntDescriptor) do
      IgorSchema.IntDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.FloatDescriptor) do
      IgorSchema.FloatDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.StringDescriptor) do
      IgorSchema.StringDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.BinaryDescriptor) do
      IgorSchema.BinaryDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.ListDescriptor) do
      IgorSchema.ListDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.DictDescriptor) do
      IgorSchema.DictDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.EnumDescriptor) do
      IgorSchema.EnumDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.RecordDescriptor) do
      IgorSchema.RecordDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.UnionDescriptor) do
      IgorSchema.UnionDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.KeyDescriptor) do
      IgorSchema.KeyDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.LocalizedDescriptor) do
      IgorSchema.LocalizedDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.DateTimeDescriptor) do
      IgorSchema.DateTimeDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.JsonDescriptor) do
      IgorSchema.JsonDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.CustomDescriptor) do
      IgorSchema.CustomDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.GenericInstanceDescriptor) do
      IgorSchema.GenericInstanceDescriptor.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.GenericArgumentDescriptor) do
      IgorSchema.GenericArgumentDescriptor.to_json!(struct)
    end

  end

  defmodule BoolDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, default: nil]

    @type t :: %BoolDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, default: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      default = Igor.Json.parse_field!(json, "default", :boolean, nil)
      %BoolDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :bool, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("default", default, :boolean)
    end

  end

  defmodule IntTypeName do

    @type t ::
      :int8 #
    | :uint8 #
    | :int16 #
    | :uint16 #
    | :int32 #
    | :uint32 #
    | :int64 #
    | :uint64 #

    defguard is_int_type_name(value) when value === :int8 or value === :uint8 or value === :int16 or value === :uint16 or value === :int32 or value === :uint32 or value === :int64 or value === :uint64

    @spec from_string!(String.t()) :: t()
    def from_string!("int8"), do: :int8
    def from_string!("uint8"), do: :uint8
    def from_string!("int16"), do: :int16
    def from_string!("uint16"), do: :uint16
    def from_string!("int32"), do: :int32
    def from_string!("uint32"), do: :uint32
    def from_string!("int64"), do: :int64
    def from_string!("uint64"), do: :uint64

    @spec to_string!(t()) :: String.t()
    def to_string!(:int8), do: "int8"
    def to_string!(:uint8), do: "uint8"
    def to_string!(:int16), do: "int16"
    def to_string!(:uint16), do: "uint16"
    def to_string!(:int32), do: "int32"
    def to_string!(:uint32), do: "uint32"
    def to_string!(:int64), do: "int64"
    def to_string!(:uint64), do: "uint64"

    @spec from_json!(String.t()) :: t()
    def from_json!("int8"), do: :int8
    def from_json!("uint8"), do: :uint8
    def from_json!("int16"), do: :int16
    def from_json!("uint16"), do: :uint16
    def from_json!("int32"), do: :int32
    def from_json!("uint32"), do: :uint32
    def from_json!("int64"), do: :int64
    def from_json!("uint64"), do: :uint64

    @spec to_json!(t()) :: String.t()
    def to_json!(:int8), do: "int8"
    def to_json!(:uint8), do: "uint8"
    def to_json!(:int16), do: "int16"
    def to_json!(:uint16), do: "uint16"
    def to_json!(:int32), do: "int32"
    def to_json!(:uint32), do: "uint32"
    def to_json!(:int64), do: "int64"
    def to_json!(:uint64), do: "uint64"

  end

  defmodule IntDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, default: nil, min: nil, max: nil, type: nil]

    @type t :: %IntDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, default: integer | nil, min: integer | nil, max: integer | nil, type: IgorSchema.IntTypeName.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      default = Igor.Json.parse_field!(json, "default", :int, nil)
      min = Igor.Json.parse_field!(json, "min", :int, nil)
      max = Igor.Json.parse_field!(json, "max", :int, nil)
      type = Igor.Json.parse_field!(json, "type", {:custom, IgorSchema.IntTypeName}, nil)
      %IntDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default,
        min: min,
        max: max,
        type: type
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default,
        min: min,
        max: max,
        type: type
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :int, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("default", default, :int)
        |> Igor.Json.pack_field("min", min, :int)
        |> Igor.Json.pack_field("max", max, :int)
        |> Igor.Json.pack_field("type", type, {:custom, IgorSchema.IntTypeName})
    end

  end

  defmodule FloatTypeName do

    @type t ::
      :float32 #
    | :float64 #

    defguard is_float_type_name(value) when value === :float32 or value === :float64

    @spec from_string!(String.t()) :: t()
    def from_string!("float32"), do: :float32
    def from_string!("float64"), do: :float64

    @spec to_string!(t()) :: String.t()
    def to_string!(:float32), do: "float32"
    def to_string!(:float64), do: "float64"

    @spec from_json!(String.t()) :: t()
    def from_json!("float32"), do: :float32
    def from_json!("float64"), do: :float64

    @spec to_json!(t()) :: String.t()
    def to_json!(:float32), do: "float32"
    def to_json!(:float64), do: "float64"

  end

  defmodule FloatDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, default: nil, min: nil, max: nil, type: nil]

    @type t :: %FloatDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, default: float | nil, min: float | nil, max: float | nil, type: IgorSchema.FloatTypeName.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      default = Igor.Json.parse_field!(json, "default", :double, nil)
      min = Igor.Json.parse_field!(json, "min", :double, nil)
      max = Igor.Json.parse_field!(json, "max", :double, nil)
      type = Igor.Json.parse_field!(json, "type", {:custom, IgorSchema.FloatTypeName}, nil)
      %FloatDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default,
        min: min,
        max: max,
        type: type
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default,
        min: min,
        max: max,
        type: type
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :float, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("default", default, :double)
        |> Igor.Json.pack_field("min", min, :double)
        |> Igor.Json.pack_field("max", max, :double)
        |> Igor.Json.pack_field("type", type, {:custom, IgorSchema.FloatTypeName})
    end

  end

  defmodule PathOptions do

    defstruct [root: nil, default_path: nil, extension: nil, include_extension: nil]

    @type t :: %PathOptions{root: String.t() | nil, default_path: String.t() | nil, extension: String.t() | nil, include_extension: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      root = Igor.Json.parse_field!(json, "root", :string, nil)
      default_path = Igor.Json.parse_field!(json, "default_path", :string, nil)
      extension = Igor.Json.parse_field!(json, "extension", :string, nil)
      include_extension = Igor.Json.parse_field!(json, "include_extension", :boolean, nil)
      %PathOptions{
        root: root,
        default_path: default_path,
        extension: extension,
        include_extension: include_extension
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        root: root,
        default_path: default_path,
        extension: extension,
        include_extension: include_extension
      } = args
      %{}
        |> Igor.Json.pack_field("root", root, :string)
        |> Igor.Json.pack_field("default_path", default_path, :string)
        |> Igor.Json.pack_field("extension", extension, :string)
        |> Igor.Json.pack_field("include_extension", include_extension, :boolean)
    end

  end

  defmodule StringDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, default: nil, multiline: false, not_empty: false, low_cardinality: nil, source: nil, path: nil, syntax: nil]

    @type t :: %StringDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, default: String.t() | nil, multiline: boolean, not_empty: boolean, low_cardinality: boolean | nil, source: String.t() | nil, path: IgorSchema.PathOptions.t() | nil, syntax: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      default = Igor.Json.parse_field!(json, "default", :string, nil)
      multiline = Igor.Json.parse_field!(json, "multiline", :boolean, false)
      not_empty = Igor.Json.parse_field!(json, "not_empty", :boolean, false)
      low_cardinality = Igor.Json.parse_field!(json, "low_cardinality", :boolean, nil)
      source = Igor.Json.parse_field!(json, "source", :string, nil)
      path = Igor.Json.parse_field!(json, "path", {:custom, IgorSchema.PathOptions}, nil)
      syntax = Igor.Json.parse_field!(json, "syntax", :string, nil)
      %StringDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default,
        multiline: multiline,
        not_empty: not_empty,
        low_cardinality: low_cardinality,
        source: source,
        path: path,
        syntax: syntax
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        default: default,
        multiline: multiline,
        not_empty: not_empty,
        low_cardinality: low_cardinality,
        source: source,
        path: path,
        syntax: syntax
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :string, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("default", default, :string)
        |> Igor.Json.pack_field("multiline", multiline, :boolean)
        |> Igor.Json.pack_field("not_empty", not_empty, :boolean)
        |> Igor.Json.pack_field("low_cardinality", low_cardinality, :boolean)
        |> Igor.Json.pack_field("source", source, :string)
        |> Igor.Json.pack_field("path", path, {:custom, IgorSchema.PathOptions})
        |> Igor.Json.pack_field("syntax", syntax, :string)
    end

  end

  defmodule BinaryDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil]

    @type t :: %BinaryDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      %BinaryDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :binary, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
    end

  end

  defmodule ListDescriptor do

    @enforce_keys [:element]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, element: nil, default: nil]

    @type t :: %ListDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, element: IgorSchema.Descriptor.t(), default: Igor.Json.json() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      element = Igor.Json.parse_field!(json, "element", {:custom, IgorSchema.Descriptor})
      default = Igor.Json.parse_field!(json, "default", :json, nil)
      %ListDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        element: element,
        default: default
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        element: element,
        default: default
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :list, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("element", element, {:custom, IgorSchema.Descriptor})
        |> Igor.Json.pack_field("default", default, :json)
    end

  end

  defmodule DictDescriptor do

    @enforce_keys [:key, :value]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, key: nil, value: nil, default: nil]

    @type t :: %DictDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, key: IgorSchema.Descriptor.t(), value: IgorSchema.Descriptor.t(), default: Igor.Json.json() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      key = Igor.Json.parse_field!(json, "key", {:custom, IgorSchema.Descriptor})
      value = Igor.Json.parse_field!(json, "value", {:custom, IgorSchema.Descriptor})
      default = Igor.Json.parse_field!(json, "default", :json, nil)
      %DictDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        key: key,
        value: value,
        default: default
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        key: key,
        value: value,
        default: default
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :dict, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("key", key, {:custom, IgorSchema.Descriptor})
        |> Igor.Json.pack_field("value", value, {:custom, IgorSchema.Descriptor})
        |> Igor.Json.pack_field("default", default, :json)
    end

  end

  defmodule EnumDescriptor do

    @enforce_keys [:name]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, name: nil, default: nil]

    @type t :: %EnumDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, name: IgorSchema.custom_type_name(), default: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      name = Igor.Json.parse_field!(json, "name", :string)
      default = Igor.Json.parse_field!(json, "default", :string, nil)
      %EnumDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        default: default
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        default: default
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :enum, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("default", default, :string)
    end

  end

  defmodule RecordDescriptor do

    @enforce_keys [:name]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, name: nil, compact: false]

    @type t :: %RecordDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, name: IgorSchema.custom_type_name(), compact: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      name = Igor.Json.parse_field!(json, "name", :string)
      compact = Igor.Json.parse_field!(json, "compact", :boolean, false)
      %RecordDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        compact: compact
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        compact: compact
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :record, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("compact", compact, :boolean)
    end

  end

  defmodule UnionDescriptor do

    @enforce_keys [:name]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, name: nil, compact: false]

    @type t :: %UnionDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, name: IgorSchema.custom_type_name(), compact: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      name = Igor.Json.parse_field!(json, "name", :string)
      compact = Igor.Json.parse_field!(json, "compact", :boolean, false)
      %UnionDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        compact: compact
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        compact: compact
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :union, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("compact", compact, :boolean)
    end

  end

  defmodule KeyDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, category: nil, interface: nil]

    @type t :: %KeyDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, category: String.t() | nil, interface: IgorSchema.interface_name() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      category = Igor.Json.parse_field!(json, "category", :string, nil)
      interface = Igor.Json.parse_field!(json, "interface", :string, nil)
      %KeyDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        category: category,
        interface: interface
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        category: category,
        interface: interface
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :key, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("category", category, :string)
        |> Igor.Json.pack_field("interface", interface, :string)
    end

  end

  defmodule LocalizedDescriptor do

    @enforce_keys [:name]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, name: nil, multiline: false]

    @type t :: %LocalizedDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, name: IgorSchema.custom_type_name(), multiline: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      name = Igor.Json.parse_field!(json, "name", :string)
      multiline = Igor.Json.parse_field!(json, "multiline", :boolean, false)
      %LocalizedDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        multiline: multiline
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name,
        multiline: multiline
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :localized, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("multiline", multiline, :boolean)
    end

  end

  defmodule DateTimeDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil]

    @type t :: %DateTimeDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      %DateTimeDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :datetime, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
    end

  end

  defmodule JsonDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil]

    @type t :: %JsonDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      %JsonDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :json, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
    end

  end

  defmodule CustomDescriptor do

    defstruct [optional: false, help: nil, editor_key: nil, meta: nil]

    @type t :: %CustomDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      %CustomDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :custom, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
    end

  end

  defmodule GenericInstanceDescriptor do

    @enforce_keys [:prototype, :arguments]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, prototype: nil, arguments: nil]

    @type t :: %GenericInstanceDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, prototype: IgorSchema.custom_type_name(), arguments: [IgorSchema.Descriptor.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      prototype = Igor.Json.parse_field!(json, "prototype", :string)
      arguments = Igor.Json.parse_field!(json, "arguments", {:list, {:custom, IgorSchema.Descriptor}})
      %GenericInstanceDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        prototype: prototype,
        arguments: arguments
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        prototype: prototype,
        arguments: arguments
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :generic_instance, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("prototype", prototype, :string)
        |> Igor.Json.pack_field("arguments", arguments, {:list, {:custom, IgorSchema.Descriptor}})
    end

  end

  defmodule GenericArgumentDescriptor do

    @enforce_keys [:name]
    defstruct [optional: false, help: nil, editor_key: nil, meta: nil, name: nil]

    @type t :: %GenericArgumentDescriptor{optional: boolean, help: String.t() | nil, editor_key: atom | nil, meta: %{String.t() => Igor.Json.json()} | nil, name: IgorSchema.generic_argument_name()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      optional = Igor.Json.parse_field!(json, "optional", :boolean, false)
      help = Igor.Json.parse_field!(json, "help", :string, nil)
      editor_key = Igor.Json.parse_field!(json, "editor_key", :atom, nil)
      meta = Igor.Json.parse_field!(json, "meta", {:map, :string, :json}, nil)
      name = Igor.Json.parse_field!(json, "name", :string)
      %GenericArgumentDescriptor{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        optional: optional,
        help: help,
        editor_key: editor_key,
        meta: meta,
        name: name
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :generic_argument, {:custom, IgorSchema.DescriptorKind})
        |> Igor.Json.pack_field("optional", optional, :boolean)
        |> Igor.Json.pack_field("help", help, :string)
        |> Igor.Json.pack_field("editor_key", editor_key, :atom)
        |> Igor.Json.pack_field("meta", meta, {:map, :string, :json})
        |> Igor.Json.pack_field("name", name, :string)
    end

  end

  defmodule CustomTypeKind do

    @type t ::
      :record #
    | :variant #
    | :enum #
    | :union #

    defguard is_custom_type_kind(value) when value === :record or value === :variant or value === :enum or value === :union

    @spec from_string!(String.t()) :: t()
    def from_string!("record"), do: :record
    def from_string!("variant"), do: :variant
    def from_string!("enum"), do: :enum
    def from_string!("union"), do: :union

    @spec to_string!(t()) :: String.t()
    def to_string!(:record), do: "record"
    def to_string!(:variant), do: "variant"
    def to_string!(:enum), do: "enum"
    def to_string!(:union), do: "union"

    @spec from_json!(String.t()) :: t()
    def from_json!("record"), do: :record
    def from_json!("variant"), do: :variant
    def from_json!("enum"), do: :enum
    def from_json!("union"), do: :union

    @spec to_json!(t()) :: String.t()
    def to_json!(:record), do: "record"
    def to_json!(:variant), do: "variant"
    def to_json!(:enum), do: "enum"
    def to_json!(:union), do: "union"

  end

  defmodule CustomType do

    @type t :: IgorSchema.StructCustomType.t() | IgorSchema.EnumCustomType.t() | IgorSchema.UnionCustomType.t()

    @spec from_json!(Igor.Json.json()) :: t() | no_return
    def from_json!(json) do
      tag = Igor.Json.parse_field!(json, "kind", {:custom, IgorSchema.CustomTypeKind})
      case tag do
        :record -> IgorSchema.RecordCustomType.from_json!(json)
        :variant -> IgorSchema.VariantCustomType.from_json!(json)
        :enum -> IgorSchema.EnumCustomType.from_json!(json)
        :union -> IgorSchema.UnionCustomType.from_json!(json)
      end
    end

    @spec to_json!(t()) :: Igor.Json.json() | no_return
    def to_json!(struct) when is_struct(struct, IgorSchema.RecordCustomType) do
      IgorSchema.RecordCustomType.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.VariantCustomType) do
      IgorSchema.VariantCustomType.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.EnumCustomType) do
      IgorSchema.EnumCustomType.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.UnionCustomType) do
      IgorSchema.UnionCustomType.to_json!(struct)
    end

  end

  defmodule StructCustomType do

    @type t :: IgorSchema.RecordCustomType.t() | IgorSchema.VariantCustomType.t()

    @spec from_json!(Igor.Json.json()) :: t() | no_return
    def from_json!(json) do
      tag = Igor.Json.parse_field!(json, "kind", {:custom, IgorSchema.CustomTypeKind})
      case tag do
        :record -> IgorSchema.RecordCustomType.from_json!(json)
        :variant -> IgorSchema.VariantCustomType.from_json!(json)
      end
    end

    @spec to_json!(t()) :: Igor.Json.json() | no_return
    def to_json!(struct) when is_struct(struct, IgorSchema.RecordCustomType) do
      IgorSchema.RecordCustomType.to_json!(struct)
    end
    def to_json!(struct) when is_struct(struct, IgorSchema.VariantCustomType) do
      IgorSchema.VariantCustomType.to_json!(struct)
    end

  end

  defmodule RecordCustomType do

    @enforce_keys [:fields, :interfaces]
    defstruct [fields: nil, parent: nil, interfaces: nil, generic_arguments: nil, group: nil]

    @type t :: %RecordCustomType{fields: Jason.OrderedObject.t(String.t(), IgorSchema.Descriptor.t()), parent: IgorSchema.custom_type_name() | nil, interfaces: [IgorSchema.interface_name_definition()], generic_arguments: [IgorSchema.generic_argument_name()] | nil, group: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      fields = Igor.Json.parse_field!(json, "fields", {:custom, Util.OrderedObject, {:string, {:custom, IgorSchema.Descriptor}}})
      parent = Igor.Json.parse_field!(json, "parent", :string, nil)
      interfaces = Igor.Json.parse_field!(json, "interfaces", {:list, :string})
      generic_arguments = Igor.Json.parse_field!(json, "generic_arguments", {:list, :string}, nil)
      group = Igor.Json.parse_field!(json, "group", :string, nil)
      %RecordCustomType{
        fields: fields,
        parent: parent,
        interfaces: interfaces,
        generic_arguments: generic_arguments,
        group: group
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        fields: fields,
        parent: parent,
        interfaces: interfaces,
        generic_arguments: generic_arguments,
        group: group
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :record, {:custom, IgorSchema.CustomTypeKind})
        |> Igor.Json.pack_field("fields", fields, {:custom, Util.OrderedObject, {:string, {:custom, IgorSchema.Descriptor}}})
        |> Igor.Json.pack_field("parent", parent, :string)
        |> Igor.Json.pack_field("interfaces", interfaces, {:list, :string})
        |> Igor.Json.pack_field("generic_arguments", generic_arguments, {:list, :string})
        |> Igor.Json.pack_field("group", group, :string)
    end

  end

  defmodule VariantCustomType do

    @enforce_keys [:fields, :interfaces, :tag, :children]
    defstruct [fields: nil, parent: nil, interfaces: nil, tag: nil, children: nil]

    @type t :: %VariantCustomType{fields: Jason.OrderedObject.t(String.t(), IgorSchema.Descriptor.t()), parent: IgorSchema.custom_type_name() | nil, interfaces: [IgorSchema.interface_name_definition()], tag: String.t(), children: %{String.t() => IgorSchema.custom_type_name()}}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      fields = Igor.Json.parse_field!(json, "fields", {:custom, Util.OrderedObject, {:string, {:custom, IgorSchema.Descriptor}}})
      parent = Igor.Json.parse_field!(json, "parent", :string, nil)
      interfaces = Igor.Json.parse_field!(json, "interfaces", {:list, :string})
      tag = Igor.Json.parse_field!(json, "tag", :string)
      children = Igor.Json.parse_field!(json, "children", {:map, :string, :string})
      %VariantCustomType{
        fields: fields,
        parent: parent,
        interfaces: interfaces,
        tag: tag,
        children: children
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        fields: fields,
        parent: parent,
        interfaces: interfaces,
        tag: tag,
        children: children
      } = args
      %{}
        |> Igor.Json.pack_field("kind", :variant, {:custom, IgorSchema.CustomTypeKind})
        |> Igor.Json.pack_field("fields", fields, {:custom, Util.OrderedObject, {:string, {:custom, IgorSchema.Descriptor}}})
        |> Igor.Json.pack_field("parent", parent, :string)
        |> Igor.Json.pack_field("interfaces", interfaces, {:list, :string})
        |> Igor.Json.pack_field("tag", tag, :string)
        |> Igor.Json.pack_field("children", children, {:map, :string, :string})
    end

  end

  defmodule EnumCustomType do

    @enforce_keys [:values]
    defstruct [values: nil]

    @type t :: %EnumCustomType{values: [String.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      values = Igor.Json.parse_field!(json, "values", {:list, :string})
      %EnumCustomType{values: values}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{values: values} = args
      %{
        "kind" => IgorSchema.CustomTypeKind.to_json!(:enum),
        "values" => Igor.Json.pack_value(values, {:list, :string})
      }
    end

  end

  defmodule UnionCustomType do

    @enforce_keys [:clauses]
    defstruct [clauses: nil, generic_arguments: nil]

    @type t :: %UnionCustomType{clauses: %{String.t() => IgorSchema.Descriptor.t() | nil}, generic_arguments: [IgorSchema.generic_argument_name()] | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      clauses = Igor.Json.parse_field!(json, "clauses", {:map, :string, {:option, {:custom, IgorSchema.Descriptor}}})
      generic_arguments = Igor.Json.parse_field!(json, "generic_arguments", {:list, :string}, nil)
      %UnionCustomType{clauses: clauses, generic_arguments: generic_arguments}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{clauses: clauses, generic_arguments: generic_arguments} = args
      %{}
        |> Igor.Json.pack_field("kind", :union, {:custom, IgorSchema.CustomTypeKind})
        |> Igor.Json.pack_field("clauses", clauses, {:map, :string, {:option, {:custom, IgorSchema.Descriptor}}})
        |> Igor.Json.pack_field("generic_arguments", generic_arguments, {:list, :string})
    end

  end

  defmodule Schema do

    @enforce_keys [:custom_types, :document_type]
    defstruct [custom_types: nil, document_type: nil, version: "1.0"]

    @type t :: %Schema{custom_types: %{IgorSchema.custom_type_name_definition() => IgorSchema.CustomType.t()}, document_type: IgorSchema.custom_type_name(), version: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      custom_types = Igor.Json.parse_field!(json, "custom_types", {:map, :string, {:custom, IgorSchema.CustomType}})
      document_type = Igor.Json.parse_field!(json, "document_type", :string)
      version = Igor.Json.parse_field!(json, "version", :string, "1.0")
      %Schema{custom_types: custom_types, document_type: document_type, version: version}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{custom_types: custom_types, document_type: document_type, version: version} = args
      %{
        "custom_types" => Igor.Json.pack_value(custom_types, {:map, :string, {:custom, IgorSchema.CustomType}}),
        "document_type" => Igor.Json.pack_value(document_type, :string),
        "version" => Igor.Json.pack_value(version, :string)
      }
    end

  end

  @type custom_type_name :: String.t()

  @type custom_type_name_definition :: IgorSchema.custom_type_name()

  @type interface_name :: String.t()

  @type interface_name_definition :: String.t()

  @type generic_argument_name :: String.t()

end
