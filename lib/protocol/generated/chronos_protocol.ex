# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule ChronosProtocol do

  defmodule GenericResponse do

    @enforce_keys [:result]
    defstruct [result: nil]

    @type t :: %GenericResponse{result: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      result = Igor.Json.parse_field!(json, "result", :boolean)
      %GenericResponse{result: result}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{result: result} = args
      %{
        "result" => Igor.Json.pack_value(result, :boolean)
      }
    end

  end

  defmodule BadRequestError do

    defexception [error: nil]

    @type t(tt) :: %BadRequestError{error: tt}

    @spec message(t(term)) :: String.t()
    def message(_), do: "BadRequestError"

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      error = Igor.Json.parse_field!(json, "error", tt_type)
      %BadRequestError{error: error}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{error: error} = args
      %{
        "error" => Igor.Json.pack_value(error, tt_type)
      }
    end

  end

  defmodule ForbiddenError do

    defexception []

    @type t :: %ForbiddenError{}

    @spec message(t()) :: String.t()
    def message(_), do: "ForbiddenError"

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(%{}), do: %ForbiddenError{}

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(%ForbiddenError{}), do: %{}

  end

  defmodule NotFoundError do

    defexception []

    @type t :: %NotFoundError{}

    @spec message(t()) :: String.t()
    def message(_), do: "NotFoundError"

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(%{}), do: %NotFoundError{}

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(%NotFoundError{}), do: %{}

  end

  defmodule LogLevel do

    @type t :: :trace | :debug | :info | :notice | :warning | :error | :fatal

    defguard is_log_level(value) when value === :trace or value === :debug or value === :info or value === :notice or value === :warning or value === :error or value === :fatal

    @spec from_string!(String.t()) :: t()
    def from_string!("trace"), do: :trace
    def from_string!("debug"), do: :debug
    def from_string!("info"), do: :info
    def from_string!("notice"), do: :notice
    def from_string!("warning"), do: :warning
    def from_string!("error"), do: :error
    def from_string!("fatal"), do: :fatal

    @spec to_string!(t()) :: String.t()
    def to_string!(:trace), do: "trace"
    def to_string!(:debug), do: "debug"
    def to_string!(:info), do: "info"
    def to_string!(:notice), do: "notice"
    def to_string!(:warning), do: "warning"
    def to_string!(:error), do: "error"
    def to_string!(:fatal), do: "fatal"

    @spec from_json!(String.t()) :: t()
    def from_json!("trace"), do: :trace
    def from_json!("debug"), do: :debug
    def from_json!("info"), do: :info
    def from_json!("notice"), do: :notice
    def from_json!("warning"), do: :warning
    def from_json!("error"), do: :error
    def from_json!("fatal"), do: :fatal

    @spec to_json!(t()) :: String.t()
    def to_json!(:trace), do: "trace"
    def to_json!(:debug), do: "debug"
    def to_json!(:info), do: "info"
    def to_json!(:notice), do: "notice"
    def to_json!(:warning), do: "warning"
    def to_json!(:error), do: "error"
    def to_json!(:fatal), do: "fatal"

  end

  defmodule IngestionError do

    @type t :: :invalid_app | :invalid_component | :invalid_branch | :invalid_version | :no_logs_to_ingest

    defguard is_ingestion_error(value) when value === :invalid_app or value === :invalid_component or value === :invalid_branch or value === :invalid_version or value === :no_logs_to_ingest

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_app"), do: :invalid_app
    def from_string!("invalid_component"), do: :invalid_component
    def from_string!("invalid_branch"), do: :invalid_branch
    def from_string!("invalid_version"), do: :invalid_version
    def from_string!("no_logs_to_ingest"), do: :no_logs_to_ingest

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_app), do: "invalid_app"
    def to_string!(:invalid_component), do: "invalid_component"
    def to_string!(:invalid_branch), do: "invalid_branch"
    def to_string!(:invalid_version), do: "invalid_version"
    def to_string!(:no_logs_to_ingest), do: "no_logs_to_ingest"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_app"), do: :invalid_app
    def from_json!("invalid_component"), do: :invalid_component
    def from_json!("invalid_branch"), do: :invalid_branch
    def from_json!("invalid_version"), do: :invalid_version
    def from_json!("no_logs_to_ingest"), do: :no_logs_to_ingest

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_app), do: "invalid_app"
    def to_json!(:invalid_component), do: "invalid_component"
    def to_json!(:invalid_branch), do: "invalid_branch"
    def to_json!(:invalid_version), do: "invalid_version"
    def to_json!(:no_logs_to_ingest), do: "no_logs_to_ingest"

  end

  defmodule IngestedLogEntry do

    @enforce_keys [:level, :timestamp, :data, :message, :msg_count, :seq_id]
    defstruct [level: nil, timestamp: nil, data: nil, message: nil, msg_count: nil, seq_id: nil]

    @type t :: %IngestedLogEntry{level: ChronosProtocol.LogLevel.t(), timestamp: ChronosProtocol.date_time(), data: Igor.Json.json(), message: String.t(), msg_count: integer, seq_id: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      level = Igor.Json.parse_field!(json, "level", {:custom, ChronosProtocol.LogLevel})
      timestamp = Igor.Json.parse_field!(json, "timestamp", :string)
      data = Igor.Json.parse_field!(json, "data", :json)
      message = Igor.Json.parse_field!(json, "message", :string)
      msg_count = Igor.Json.parse_field!(json, "msg_count", :int)
      seq_id = Igor.Json.parse_field!(json, "seq_id", :int)
      %IngestedLogEntry{
        level: level,
        timestamp: timestamp,
        data: data,
        message: message,
        msg_count: msg_count,
        seq_id: seq_id
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        level: level,
        timestamp: timestamp,
        data: data,
        message: message,
        msg_count: msg_count,
        seq_id: seq_id
      } = args
      %{
        "level" => ChronosProtocol.LogLevel.to_json!(level),
        "timestamp" => Igor.Json.pack_value(timestamp, :string),
        "data" => data,
        "message" => Igor.Json.pack_value(message, :string),
        "msg_count" => Igor.Json.pack_value(msg_count, :int),
        "seq_id" => Igor.Json.pack_value(seq_id, :int)
      }
    end

  end

  defmodule ChronosApi do

    @spec push_logs([ChronosProtocol.IngestedLogEntry.t()], String.t(), String.t(), String.t(), String.t(), String.t()) :: ChronosProtocol.GenericResponse.t()
    def push_logs(request_content, app, component, branch, version, api_key) do
      request_headers = [{"x-api-key", api_key}, {"content-type", "application/json"}]
      request_body = request_content
        |> Igor.Json.pack_value({:list, {:custom, ChronosProtocol.IngestedLogEntry}})
        |> Igor.Json.encode!()
      url = "#{Application.get_env(:logger, Logger.Backends.Chronos)[:url]}/#{app}/#{component}/#{branch}/#{version}"
      case HTTPoison.post(url, request_body, request_headers, []) do
        {:ok, %HTTPoison.Response{status_code: 201, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, ChronosProtocol.GenericResponse})
        {:ok, %HTTPoison.Response{status_code: 400, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, ChronosProtocol.BadRequestError, {{:custom, ChronosProtocol.IngestionError}}})
        {:ok, %HTTPoison.Response{status_code: 403, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, ChronosProtocol.ForbiddenError})
        {:ok, %HTTPoison.Response{status_code: status_code, body: response_body, headers: response_headers}} ->
          raise %Igor.Http.HttpError{status_code: status_code, body: response_body, headers: response_headers}
        {:error, %HTTPoison.Error{reason: _} = e} ->
          raise e
      end
    end

  end

  @type date_time :: String.t()

end
