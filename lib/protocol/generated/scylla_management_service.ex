# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.ScyllaManagementService do

  use Plug.Router
  require Logger

  @doc """
  Get ClickHouse instances
  """
  @callback get_clickhouse_instances(String.t() | nil, Map.t() | nil) :: DataProtocol.Collection.t(WebProtocol.ClickhouseInstance.t()) | no_return

  @doc """
  Create a ClickHouse instance
  """
  @callback create_clickhouse_instance(String.t() | nil, WebProtocol.CreateClickhouseInstanceRequest.t(), Map.t() | nil) :: WebProtocol.ClickhouseInstance.t() | no_return

  @doc """
  Get a ClickHouse instance
  """
  @callback get_clickhouse_instance(TypesProtocol.clickhouse_instance_id(), String.t() | nil, Map.t() | nil) :: WebProtocol.ClickhouseInstance.t() | no_return

  @doc """
  Update a ClickHouse instance
  """
  @callback update_clickhouse_instance(TypesProtocol.clickhouse_instance_id(), String.t() | nil, WebProtocol.UpdateClickhouseInstanceRequest.t(), Map.t() | nil) :: WebProtocol.ClickhouseInstance.t() | no_return

  @doc """
  Delete a ClickHouse instance
  """
  @callback delete_clickhouse_instance(TypesProtocol.clickhouse_instance_id(), String.t() | nil, Map.t() | nil) :: any | no_return

  @doc """
  Get projects
  """
  @callback get_projects(String.t() | nil, Map.t() | nil) :: DataProtocol.Collection.t(WebProtocol.Project.t()) | no_return

  @doc """
  Create a project
  """
  @callback create_project(boolean, String.t() | nil, WebProtocol.CreateProjectRequest.t(), Map.t() | nil) :: WebProtocol.Project.t() | no_return

  @doc """
  Get a project
  """
  @callback get_project(TypesProtocol.project_id(), String.t() | nil, Map.t() | nil) :: WebProtocol.Project.t() | no_return

  @doc """
  Update a project
  """
  @callback update_project(TypesProtocol.project_id(), boolean, String.t() | nil, WebProtocol.UpdateProjectRequest.t(), Map.t() | nil) :: WebProtocol.Project.t() | no_return

  @doc """
  Delete a project
  """
  @callback delete_project(TypesProtocol.project_id(), boolean, String.t() | nil, Map.t() | nil) :: any | no_return

  @doc """
  Fetch list of backup fields
  """
  @callback get_backup_fields(TypesProtocol.project_id(), WebProtocol.BackupFieldsOrderBy.t(), DataProtocol.OrderDirection.t(), non_neg_integer, non_neg_integer, String.t() | nil, Map.t() | nil) :: DataProtocol.CollectionSlice.t(String.t()) | no_return

  @doc """
  Drop backup fields by name
  """
  @callback drop_backup_fields(TypesProtocol.project_id(), String.t() | nil, [String.t()], Map.t() | nil) :: any | no_return

  @doc """
  Fetch last N project events
  """
  @callback fetch_project_events(TypesProtocol.project_id(), integer, String.t() | nil, Map.t() | nil) :: [Igor.Json.json()] | no_return

  @doc """
  Fetch migrations collection slice
  """
  @callback fetch_schema_migrations(TypesProtocol.project_id(), WebProtocol.SchemaMigrationOrderBy.t(), DataProtocol.OrderDirection.t(), non_neg_integer, non_neg_integer, String.t() | nil, Map.t() | nil) :: DataProtocol.CollectionSlice.t(WebProtocol.SchemaMigration.t()) | no_return

  @doc """
  Fetch a migration
  """
  @callback fetch_schema_migration(TypesProtocol.project_id(), integer, String.t() | nil, Map.t() | nil) :: WebProtocol.SchemaMigration.t() | no_return

  @doc """
  Regenerate project key
  """
  @callback regenerate_project_key(TypesProtocol.project_id(), atom, String.t() | nil, DataProtocol.Empty.t(), Map.t() | nil) :: WebProtocol.Project.t() | no_return

  plug :match
  plug :dispatch

  # ----------------------------------------------------------------------------
  # Get ClickHouse instances
  # ----------------------------------------------------------------------------

  get "/clickhouse", [] do
    resource__ = "WebProtocol.ScyllaManagementService.GetClickhouseInstances"
    try do
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.get_clickhouse_instances", args: [api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.get_clickhouse_instances(api_key, current_user) do
        response_content ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, WebProtocol.ClickhouseInstance}}})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Create a ClickHouse instance
  # ----------------------------------------------------------------------------

  post "/clickhouse", [] do
    resource__ = "WebProtocol.ScyllaManagementService.CreateClickhouseInstance"
    try do
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      if get_req_header(conn, "content-type") != ["application/json"], do: raise Plug.BadRequestError, "The request must have header 'content-type' equal to 'application/json'"
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:custom, WebProtocol.CreateClickhouseInstanceRequest})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.create_clickhouse_instance", args: [api_key: api_key, request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.create_clickhouse_instance(api_key, request_content, current_user) do
        response_content when is_struct(response_content, WebProtocol.ClickhouseInstance) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.ClickhouseInstance})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(201, body)
      end
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.warn("rpc_err: #{resource__}", data: %{exception: e}, domain: [:rpc])
        body = e
          |> Igor.Exception.wrap()
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.ClickhouseInstanceError}}})
          |> Igor.Json.encode!()
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Get a ClickHouse instance
  # ----------------------------------------------------------------------------

  get "/clickhouse/:id_or_code", [] do
    resource__ = "WebProtocol.ScyllaManagementService.GetClickhouseInstance"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ClickhouseInstanceId})
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.get_clickhouse_instance", args: [id_or_code: id_or_code, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.get_clickhouse_instance(id_or_code, api_key, current_user) do
        response_content when is_struct(response_content, WebProtocol.ClickhouseInstance) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.ClickhouseInstance})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Update a ClickHouse instance
  # ----------------------------------------------------------------------------

  patch "/clickhouse/:id_or_code", [] do
    resource__ = "WebProtocol.ScyllaManagementService.UpdateClickhouseInstance"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ClickhouseInstanceId})
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      if get_req_header(conn, "content-type") != ["application/json"], do: raise Plug.BadRequestError, "The request must have header 'content-type' equal to 'application/json'"
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:custom, WebProtocol.UpdateClickhouseInstanceRequest})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.update_clickhouse_instance", args: [id_or_code: id_or_code, api_key: api_key, request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.update_clickhouse_instance(id_or_code, api_key, request_content, current_user) do
        response_content when is_struct(response_content, WebProtocol.ClickhouseInstance) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.ClickhouseInstance})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.warn("rpc_err: #{resource__}", data: %{exception: e}, domain: [:rpc])
        body = e
          |> Igor.Exception.wrap()
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.ClickhouseInstanceError}}})
          |> Igor.Json.encode!()
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Delete a ClickHouse instance
  # ----------------------------------------------------------------------------

  delete "/clickhouse/:id_or_code", [] do
    resource__ = "WebProtocol.ScyllaManagementService.DeleteClickhouseInstance"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ClickhouseInstanceId})
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.delete_clickhouse_instance", args: [id_or_code: id_or_code, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.delete_clickhouse_instance(id_or_code, api_key, current_user) do
        true ->
          Logger.info("rpc_res: #{resource__}", data: %{result: true}, domain: [:rpc])
          conn
            |> send_resp(204, "")
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Get projects
  # ----------------------------------------------------------------------------

  get "/projects", [] do
    resource__ = "WebProtocol.ScyllaManagementService.GetProjects"
    try do
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.get_projects", args: [api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.get_projects(api_key, current_user) do
        response_content ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, WebProtocol.Project}}})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Create a project
  # ----------------------------------------------------------------------------

  post "/projects", [] do
    resource__ = "WebProtocol.ScyllaManagementService.CreateProject"
    try do
      keep_db = Igor.Json.parse_field!(conn.query_params, "keep_db", :boolean, true)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      if get_req_header(conn, "content-type") != ["application/json"], do: raise Plug.BadRequestError, "The request must have header 'content-type' equal to 'application/json'"
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:custom, WebProtocol.CreateProjectRequest})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.create_project", args: [keep_db: keep_db, api_key: api_key, request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.create_project(keep_db, api_key, request_content, current_user) do
        response_content when is_struct(response_content, WebProtocol.Project) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.Project})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(201, body)
      end
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.warn("rpc_err: #{resource__}", data: %{exception: e}, domain: [:rpc])
        body = e
          |> Igor.Exception.wrap()
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.ProjectError}}})
          |> Igor.Json.encode!()
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Get a project
  # ----------------------------------------------------------------------------

  get "/projects/:id_or_code", [] do
    resource__ = "WebProtocol.ScyllaManagementService.GetProject"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.get_project", args: [id_or_code: id_or_code, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.get_project(id_or_code, api_key, current_user) do
        response_content when is_struct(response_content, WebProtocol.Project) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.Project})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Update a project
  # ----------------------------------------------------------------------------

  patch "/projects/:id_or_code", [] do
    resource__ = "WebProtocol.ScyllaManagementService.UpdateProject"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      keep_db = Igor.Json.parse_field!(conn.query_params, "keep_db", :boolean, true)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      if get_req_header(conn, "content-type") != ["application/json"], do: raise Plug.BadRequestError, "The request must have header 'content-type' equal to 'application/json'"
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:custom, WebProtocol.UpdateProjectRequest})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.update_project", args: [id_or_code: id_or_code, keep_db: keep_db, api_key: api_key, request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.update_project(id_or_code, keep_db, api_key, request_content, current_user) do
        response_content when is_struct(response_content, WebProtocol.Project) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.Project})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.warn("rpc_err: #{resource__}", data: %{exception: e}, domain: [:rpc])
        body = e
          |> Igor.Exception.wrap()
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.ProjectError}}})
          |> Igor.Json.encode!()
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Delete a project
  # ----------------------------------------------------------------------------

  delete "/projects/:id_or_code", [] do
    resource__ = "WebProtocol.ScyllaManagementService.DeleteProject"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      keep_db = Igor.Json.parse_field!(conn.query_params, "keep_db", :boolean, true)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.delete_project", args: [id_or_code: id_or_code, keep_db: keep_db, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.delete_project(id_or_code, keep_db, api_key, current_user) do
        true ->
          Logger.info("rpc_res: #{resource__}", data: %{result: true}, domain: [:rpc])
          conn
            |> send_resp(204, "")
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Fetch list of backup fields
  # ----------------------------------------------------------------------------

  get "/projects/:id_or_code/backup_fields", [] do
    resource__ = "WebProtocol.ScyllaManagementService.GetBackupFields"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.BackupFieldsOrderBy}, :name)
      order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection}, :asc)
      offset = Igor.Json.parse_field!(conn.query_params, "offset", :uint, 0)
      limit = Igor.Json.parse_field!(conn.query_params, "limit", :uint, 10)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.get_backup_fields", args: [id_or_code: id_or_code, order_by: order_by, order_dir: order_dir, offset: offset, limit: limit, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.get_backup_fields(id_or_code, order_by, order_dir, offset, limit, api_key, current_user) do
        response_content ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {:string}})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Drop backup fields by name
  # ----------------------------------------------------------------------------

  put "/projects/:id_or_code/backup_fields/drop", [] do
    resource__ = "WebProtocol.ScyllaManagementService.DropBackupFields"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:list, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.drop_backup_fields", args: [id_or_code: id_or_code, api_key: api_key, request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.drop_backup_fields(id_or_code, api_key, request_content, current_user) do
        true ->
          Logger.info("rpc_res: #{resource__}", data: %{result: true}, domain: [:rpc])
          conn
            |> send_resp(204, "")
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Fetch last N project events
  # ----------------------------------------------------------------------------

  get "/projects/:id_or_code/events", [] do
    resource__ = "WebProtocol.ScyllaManagementService.FetchProjectEvents"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      count = Igor.Json.parse_field!(conn.query_params, "count", :int, 10)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.fetch_project_events", args: [id_or_code: id_or_code, count: count, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.fetch_project_events(id_or_code, count, api_key, current_user) do
        response_content when is_list(response_content) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:list, :json})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Fetch migrations collection slice
  # ----------------------------------------------------------------------------

  get "/projects/:id_or_code/migrations", [] do
    resource__ = "WebProtocol.ScyllaManagementService.FetchSchemaMigrations"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.SchemaMigrationOrderBy}, :created_at)
      order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection}, :desc)
      offset = Igor.Json.parse_field!(conn.query_params, "offset", :uint, 0)
      limit = Igor.Json.parse_field!(conn.query_params, "limit", :uint, 10)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.fetch_schema_migrations", args: [id_or_code: id_or_code, order_by: order_by, order_dir: order_dir, offset: offset, limit: limit, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.fetch_schema_migrations(id_or_code, order_by, order_dir, offset, limit, api_key, current_user) do
        response_content ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, WebProtocol.SchemaMigration}}})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Fetch a migration
  # ----------------------------------------------------------------------------

  get "/projects/:id_or_code/migration/:migration_id", [] do
    resource__ = "WebProtocol.ScyllaManagementService.FetchSchemaMigration"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      migration_id = Igor.Json.parse_field!(conn.path_params, "migration_id", :long)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.fetch_schema_migration", args: [id_or_code: id_or_code, migration_id: migration_id, api_key: api_key, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.fetch_schema_migration(id_or_code, migration_id, api_key, current_user) do
        response_content when is_struct(response_content, WebProtocol.SchemaMigration) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.SchemaMigration})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # Regenerate project key
  # ----------------------------------------------------------------------------

  put "/projects/:id_or_code/:key/regenerate", [] do
    resource__ = "WebProtocol.ScyllaManagementService.RegenerateProjectKey"
    try do
      id_or_code = Igor.Json.parse_field!(conn.path_params, "id_or_code", {:custom, Scylla.ProjectId})
      key = Igor.Json.parse_field!(conn.path_params, "key", :atom)
      api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
      if get_req_header(conn, "content-type") != ["application/json"], do: raise Plug.BadRequestError, "The request must have header 'content-type' equal to 'application/json'"
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:custom, DataProtocol.Empty})
      current_user = api_key && %{role: ~s'scylla_ext', key: api_key} || conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaManagementService.Impl.regenerate_project_key", args: [id_or_code: id_or_code, key: key, api_key: api_key, request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaManagementService.Impl.regenerate_project_key(id_or_code, key, api_key, request_content, current_user) do
        response_content when is_struct(response_content, WebProtocol.Project) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.Project})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # catchall route
  match _, do: send_resp(conn, 404, "")

end
