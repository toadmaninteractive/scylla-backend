# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.ScyllaAuthService do

  use Plug.Router
  require Logger

  @doc """
  TODO: annotate WebProtocol.ScyllaAuthService.Login
  """
  @callback login(Plug.Conn.t(), WebProtocol.LoginRequest.t(), Map.t() | nil) :: {Plug.Conn.t(), WebProtocol.UserProfile.t()} | no_return

  @doc """
  TODO: annotate WebProtocol.ScyllaAuthService.Logout
  """
  @callback logout(Plug.Conn.t(), Map.t() | nil) :: Plug.Conn.t() | no_return

  @doc """
  TODO: annotate WebProtocol.ScyllaAuthService.GetMyProfile
  """
  @callback get_my_profile(Map.t() | nil) :: WebProtocol.UserProfile.t() | no_return

  plug :match
  plug :dispatch

  # ----------------------------------------------------------------------------
  # TODO: annotate WebProtocol.ScyllaAuthService.Login
  # ----------------------------------------------------------------------------

  post "/login", [] do
    resource__ = "WebProtocol.ScyllaAuthService.Login"
    try do
      {:ok, body, conn} = read_body(conn)
      request_content = body
        |> Igor.Json.decode!()
        |> Igor.Json.parse_value!({:custom, WebProtocol.LoginRequest})
      current_user = conn.assigns[:current_user]
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaAuthService.Impl.login", args: [request_content: request_content, current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaAuthService.Impl.login(conn, request_content, current_user) do
        {conn, response_content} when is_struct(response_content, WebProtocol.UserProfile) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.UserProfile})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.warn("rpc_err: #{resource__}", data: %{exception: e}, domain: [:rpc])
        body = e
          |> Igor.Exception.wrap()
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.LoginError}}})
          |> Igor.Json.encode!()
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # TODO: annotate WebProtocol.ScyllaAuthService.Logout
  # ----------------------------------------------------------------------------

  put "/logout", [] do
    resource__ = "WebProtocol.ScyllaAuthService.Logout"
    try do
      current_user = conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaAuthService.Impl.logout", args: [current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaAuthService.Impl.logout(conn, current_user) do
        conn ->
          Logger.info("rpc_res: #{resource__}", data: %{result: true}, domain: [:rpc])
          conn
            |> send_resp(204, "")
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # ----------------------------------------------------------------------------
  # TODO: annotate WebProtocol.ScyllaAuthService.GetMyProfile
  # ----------------------------------------------------------------------------

  get "/profile", [] do
    resource__ = "WebProtocol.ScyllaAuthService.GetMyProfile"
    try do
      current_user = conn.assigns[:current_user] || raise DataProtocol.UnauthorizedError
      Logger.info("rpc_req: #{resource__}", data: %{method: "WebProtocol.ScyllaAuthService.Impl.get_my_profile", args: [current_user: current_user]}, domain: [:rpc])
      ACL.can!(current_user, resource__)
      case WebProtocol.ScyllaAuthService.Impl.get_my_profile(current_user) do
        response_content when is_struct(response_content, WebProtocol.UserProfile) ->
          Logger.info("rpc_res: #{resource__}", data: %{result: response_content}, domain: [:rpc])
          body = response_content
            |> Igor.Json.pack_value({:custom, WebProtocol.UserProfile})
            |> Igor.Json.encode!()
          conn
            |> put_resp_content_type("application/json")
            |> send_resp(200, body)
      end
    rescue
      e -> Igor.Exception.handle(e, __STACKTRACE__, conn, resource__)
    end
  end

  # catchall route
  match _, do: send_resp(conn, 404, "")

end
