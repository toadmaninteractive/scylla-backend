# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule ConfigProtocol do

  defmodule Config do

    @enforce_keys [:web, :db, :ldap, :clickhouse]
    defstruct [web: nil, db: nil, ldap: nil, jobs: %{}, clickhouse: nil]

    @type t :: %Config{web: ConfigProtocol.Web.t(), db: ConfigProtocol.Db.t(), ldap: ConfigProtocol.Ldap.t(), jobs: %{atom => ConfigProtocol.CronJob.t()}, clickhouse: ConfigProtocol.Clickhouse.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      web = Igor.Json.parse_field!(json, "web", {:custom, ConfigProtocol.Web})
      db = Igor.Json.parse_field!(json, "db", {:custom, ConfigProtocol.Db})
      ldap = Igor.Json.parse_field!(json, "ldap", {:custom, ConfigProtocol.Ldap})
      jobs = Igor.Json.parse_field!(json, "jobs", {:map, :atom, {:custom, ConfigProtocol.CronJob}}, %{})
      clickhouse = Igor.Json.parse_field!(json, "clickhouse", {:custom, ConfigProtocol.Clickhouse})
      %Config{
        web: web,
        db: db,
        ldap: ldap,
        jobs: jobs,
        clickhouse: clickhouse
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        web: web,
        db: db,
        ldap: ldap,
        jobs: jobs,
        clickhouse: clickhouse
      } = args
      %{
        "web" => ConfigProtocol.Web.to_json!(web),
        "db" => ConfigProtocol.Db.to_json!(db),
        "ldap" => ConfigProtocol.Ldap.to_json!(ldap),
        "jobs" => Igor.Json.pack_value(jobs, {:map, :atom, {:custom, ConfigProtocol.CronJob}}),
        "clickhouse" => ConfigProtocol.Clickhouse.to_json!(clickhouse)
      }
    end

  end

  defmodule Web do

    @enforce_keys [:cors, :session]
    defstruct [ip: "127.0.0.1", port: 39100, cors: nil, session: nil, api_keys: []]

    @type t :: %Web{ip: String.t(), port: integer, cors: ConfigProtocol.WebCors.t(), session: ConfigProtocol.WebSession.t(), api_keys: [String.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      ip = Igor.Json.parse_field!(json, "ip", :string, "127.0.0.1")
      port = Igor.Json.parse_field!(json, "port", :int, 39100)
      cors = Igor.Json.parse_field!(json, "cors", {:custom, ConfigProtocol.WebCors})
      session = Igor.Json.parse_field!(json, "session", {:custom, ConfigProtocol.WebSession})
      api_keys = Igor.Json.parse_field!(json, "api_keys", {:list, :string}, [])
      %Web{
        ip: ip,
        port: port,
        cors: cors,
        session: session,
        api_keys: api_keys
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        ip: ip,
        port: port,
        cors: cors,
        session: session,
        api_keys: api_keys
      } = args
      %{
        "ip" => Igor.Json.pack_value(ip, :string),
        "port" => Igor.Json.pack_value(port, :int),
        "cors" => ConfigProtocol.WebCors.to_json!(cors),
        "session" => ConfigProtocol.WebSession.to_json!(session),
        "api_keys" => Igor.Json.pack_value(api_keys, {:list, :string})
      }
    end

  end

  defmodule WebCors do

    @enforce_keys [:fallback_origin, :allowed_origins]
    defstruct [fallback_origin: nil, allowed_origins: nil]

    @type t :: %WebCors{fallback_origin: String.t(), allowed_origins: [String.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      fallback_origin = Igor.Json.parse_field!(json, "fallback_origin", :string)
      allowed_origins = Igor.Json.parse_field!(json, "allowed_origins", {:list, :string})
      %WebCors{fallback_origin: fallback_origin, allowed_origins: allowed_origins}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{fallback_origin: fallback_origin, allowed_origins: allowed_origins} = args
      %{
        "fallback_origin" => Igor.Json.pack_value(fallback_origin, :string),
        "allowed_origins" => Igor.Json.pack_value(allowed_origins, {:list, :string})
      }
    end

  end

  defmodule WebSession do

    @enforce_keys [:secret, :encryption_salt, :signing_salt]
    defstruct [secret: nil, encryption_salt: nil, signing_salt: nil]

    @type t :: %WebSession{secret: String.t(), encryption_salt: String.t(), signing_salt: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      secret = Igor.Json.parse_field!(json, "secret", :string)
      encryption_salt = Igor.Json.parse_field!(json, "encryption_salt", :string)
      signing_salt = Igor.Json.parse_field!(json, "signing_salt", :string)
      %WebSession{secret: secret, encryption_salt: encryption_salt, signing_salt: signing_salt}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{secret: secret, encryption_salt: encryption_salt, signing_salt: signing_salt} = args
      %{
        "secret" => Igor.Json.pack_value(secret, :string),
        "encryption_salt" => Igor.Json.pack_value(encryption_salt, :string),
        "signing_salt" => Igor.Json.pack_value(signing_salt, :string)
      }
    end

  end

  defmodule Db do

    @enforce_keys [:url]
    defstruct [url: nil]

    @type t :: %Db{url: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      url = Igor.Json.parse_field!(json, "url", :string)
      %Db{url: url}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{url: url} = args
      %{
        "url" => Igor.Json.pack_value(url, :string)
      }
    end

  end

  defmodule Ldap do

    @enforce_keys [:server, :user_dn, :password, :base]
    defstruct [server: nil, port: 389, ssl: false, user_dn: nil, password: nil, base: nil]

    @type t :: %Ldap{server: String.t(), port: integer, ssl: boolean, user_dn: String.t(), password: String.t(), base: ConfigProtocol.LdapBase.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      server = Igor.Json.parse_field!(json, "server", :string)
      port = Igor.Json.parse_field!(json, "port", :int, 389)
      ssl = Igor.Json.parse_field!(json, "ssl", :boolean, false)
      user_dn = Igor.Json.parse_field!(json, "user_dn", :string)
      password = Igor.Json.parse_field!(json, "password", :string)
      base = Igor.Json.parse_field!(json, "base", {:custom, ConfigProtocol.LdapBase})
      %Ldap{
        server: server,
        port: port,
        ssl: ssl,
        user_dn: user_dn,
        password: password,
        base: base
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        server: server,
        port: port,
        ssl: ssl,
        user_dn: user_dn,
        password: password,
        base: base
      } = args
      %{
        "server" => Igor.Json.pack_value(server, :string),
        "port" => Igor.Json.pack_value(port, :int),
        "ssl" => Igor.Json.pack_value(ssl, :boolean),
        "user_dn" => Igor.Json.pack_value(user_dn, :string),
        "password" => Igor.Json.pack_value(password, :string),
        "base" => ConfigProtocol.LdapBase.to_json!(base)
      }
    end

  end

  defmodule LdapBase do

    @enforce_keys [:users, :groups]
    defstruct [users: nil, groups: nil]

    @type t :: %LdapBase{users: String.t(), groups: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      users = Igor.Json.parse_field!(json, "users", :string)
      groups = Igor.Json.parse_field!(json, "groups", :string)
      %LdapBase{users: users, groups: groups}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{users: users, groups: groups} = args
      %{
        "users" => Igor.Json.pack_value(users, :string),
        "groups" => Igor.Json.pack_value(groups, :string)
      }
    end

  end

  defmodule CronJob do

    @enforce_keys [:schedule]
    defstruct [schedule: nil, extended: false, module: nil, function: nil, arguments: []]

    @type t :: %CronJob{schedule: String.t(), extended: boolean, module: atom | nil, function: atom | nil, arguments: [Igor.Json.json()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      schedule = Igor.Json.parse_field!(json, "schedule", :string)
      extended = Igor.Json.parse_field!(json, "extended", :boolean, false)
      module = Igor.Json.parse_field!(json, "module", :atom, nil)
      function = Igor.Json.parse_field!(json, "function", :atom, nil)
      arguments = Igor.Json.parse_field!(json, "arguments", {:list, :json}, [])
      %CronJob{
        schedule: schedule,
        extended: extended,
        module: module,
        function: function,
        arguments: arguments
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        schedule: schedule,
        extended: extended,
        module: module,
        function: function,
        arguments: arguments
      } = args
      %{}
        |> Igor.Json.pack_field("schedule", schedule, :string)
        |> Igor.Json.pack_field("extended", extended, :boolean)
        |> Igor.Json.pack_field("module", module, :atom)
        |> Igor.Json.pack_field("function", function, :atom)
        |> Igor.Json.pack_field("arguments", arguments, {:list, :json})
    end

  end

  defmodule Clickhouse do

    @enforce_keys [:table, :save_events_directory, :transient_error_codes]
    defstruct [table: nil, save_events_directory: nil, transient_error_codes: nil]

    @type t :: %Clickhouse{table: String.t(), save_events_directory: String.t(), transient_error_codes: [non_neg_integer]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      table = Igor.Json.parse_field!(json, "table", :string)
      save_events_directory = Igor.Json.parse_field!(json, "save_events_directory", :string)
      transient_error_codes = Igor.Json.parse_field!(json, "transient_error_codes", {:list, :uint})
      %Clickhouse{table: table, save_events_directory: save_events_directory, transient_error_codes: transient_error_codes}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{table: table, save_events_directory: save_events_directory, transient_error_codes: transient_error_codes} = args
      %{
        "table" => Igor.Json.pack_value(table, :string),
        "save_events_directory" => Igor.Json.pack_value(save_events_directory, :string),
        "transient_error_codes" => Igor.Json.pack_value(transient_error_codes, {:list, :uint})
      }
    end

  end

end
