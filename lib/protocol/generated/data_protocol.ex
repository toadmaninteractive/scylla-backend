# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule DataProtocol do

  defmodule OrderDirection do

    @type t ::
      :asc #
    | :desc #

    defguard is_order_direction(value) when value === :asc or value === :desc

    @spec from_string!(String.t()) :: t()
    def from_string!("asc"), do: :asc
    def from_string!("desc"), do: :desc

    @spec to_string!(t()) :: String.t()
    def to_string!(:asc), do: "asc"
    def to_string!(:desc), do: "desc"

    @spec from_json!(String.t()) :: t()
    def from_json!("asc"), do: :asc
    def from_json!("desc"), do: :desc

    @spec to_json!(t()) :: String.t()
    def to_json!(:asc), do: "asc"
    def to_json!(:desc), do: "desc"

  end

  defmodule Collection do

    @enforce_keys [:items]
    defstruct [items: nil]

    @type t(tt) :: %Collection{items: [tt]}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      items = Igor.Json.parse_field!(json, "items", {:list, tt_type})
      %Collection{items: items}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{items: items} = args
      %{
        "items" => Igor.Json.pack_value(items, {:list, tt_type})
      }
    end

  end

  defmodule CollectionSlice do

    @enforce_keys [:total, :items]
    defstruct [total: nil, items: nil]

    @type t(tt) :: %CollectionSlice{total: non_neg_integer, items: [tt]}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      total = Igor.Json.parse_field!(json, "total", :ulong)
      items = Igor.Json.parse_field!(json, "items", {:list, tt_type})
      %CollectionSlice{total: total, items: items}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{total: total, items: items} = args
      %{
        "total" => Igor.Json.pack_value(total, :ulong),
        "items" => Igor.Json.pack_value(items, {:list, tt_type})
      }
    end

  end

  defmodule Empty do

    defstruct []

    @type t :: %Empty{}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(%{}), do: %Empty{}

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(%Empty{}), do: %{}

  end

  defmodule GenericResponse do

    @enforce_keys [:result]
    defstruct [result: nil]

    @type t :: %GenericResponse{result: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      result = Igor.Json.parse_field!(json, "result", :boolean)
      %GenericResponse{result: result}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{result: result} = args
      %{
        "result" => Igor.Json.pack_value(result, :boolean)
      }
    end

  end

  defmodule BadRequestError do

    defexception [message: "Could not process the request due to client error", log_id: nil, error: nil, details: nil, plug_status: 400]

    @type t(t_error) :: %BadRequestError{message: String.t(), log_id: String.t() | nil, error: t_error | nil, details: Igor.Json.json() | nil}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {t_error_type}) do
      message = Igor.Json.parse_field!(json, "message", :string, "Could not process the request due to client error")
      log_id = Igor.Json.parse_field!(json, "log_id", :string, nil)
      error = Igor.Json.parse_field!(json, "error", t_error_type, nil)
      details = Igor.Json.parse_field!(json, "details", :json, nil)
      %BadRequestError{
        message: message,
        log_id: log_id,
        error: error,
        details: details
      }
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {t_error_type}) do
      %{
        message: message,
        log_id: log_id,
        error: error,
        details: details
      } = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("log_id", log_id, :string)
        |> Igor.Json.pack_field("error", error, t_error_type)
        |> Igor.Json.pack_field("details", details, :json)
    end

  end

  defmodule UnauthorizedError do

    defexception [message: "Access denied. Please provide authentication data", log_id: nil, plug_status: 401]

    @type t :: %UnauthorizedError{message: String.t(), log_id: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      message = Igor.Json.parse_field!(json, "message", :string, "Access denied. Please provide authentication data")
      log_id = Igor.Json.parse_field!(json, "log_id", :string, nil)
      %UnauthorizedError{message: message, log_id: log_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{message: message, log_id: log_id} = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("log_id", log_id, :string)
    end

  end

  defmodule ForbiddenError do

    defexception [message: "Access denied. You are not authorized to perform this action", log_id: nil, plug_status: 403]

    @type t :: %ForbiddenError{message: String.t(), log_id: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      message = Igor.Json.parse_field!(json, "message", :string, "Access denied. You are not authorized to perform this action")
      log_id = Igor.Json.parse_field!(json, "log_id", :string, nil)
      %ForbiddenError{message: message, log_id: log_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{message: message, log_id: log_id} = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("log_id", log_id, :string)
    end

  end

  defmodule NotFoundError do

    defexception [message: "Requested resource not found", log_id: nil, plug_status: 404]

    @type t :: %NotFoundError{message: String.t(), log_id: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      message = Igor.Json.parse_field!(json, "message", :string, "Requested resource not found")
      log_id = Igor.Json.parse_field!(json, "log_id", :string, nil)
      %NotFoundError{message: message, log_id: log_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{message: message, log_id: log_id} = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("log_id", log_id, :string)
    end

  end

  defmodule ConflictError do

    defexception [message: "Could not complete due to a conflict with the current state of the resource", log_id: nil, error: nil, details: nil, plug_status: 409]

    @type t(t_error) :: %ConflictError{message: String.t(), log_id: String.t() | nil, error: t_error | nil, details: Igor.Json.json() | nil}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {t_error_type}) do
      message = Igor.Json.parse_field!(json, "message", :string, "Could not complete due to a conflict with the current state of the resource")
      log_id = Igor.Json.parse_field!(json, "log_id", :string, nil)
      error = Igor.Json.parse_field!(json, "error", t_error_type, nil)
      details = Igor.Json.parse_field!(json, "details", :json, nil)
      %ConflictError{
        message: message,
        log_id: log_id,
        error: error,
        details: details
      }
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {t_error_type}) do
      %{
        message: message,
        log_id: log_id,
        error: error,
        details: details
      } = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("log_id", log_id, :string)
        |> Igor.Json.pack_field("error", error, t_error_type)
        |> Igor.Json.pack_field("details", details, :json)
    end

  end

  defmodule InternalServerError do

    defexception [message: "Could not process the request due to server error. Please contact developers", log_id: nil, plug_status: 500]

    @type t :: %InternalServerError{message: String.t(), log_id: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      message = Igor.Json.parse_field!(json, "message", :string, "Could not process the request due to server error. Please contact developers")
      log_id = Igor.Json.parse_field!(json, "log_id", :string, nil)
      %InternalServerError{message: message, log_id: log_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{message: message, log_id: log_id} = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("log_id", log_id, :string)
    end

  end

end
